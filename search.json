[
  {
    "objectID": "pages/stringification.html",
    "href": "pages/stringification.html",
    "title": "Converting Lua Objects to Strings",
    "section": "",
    "text": "If you have loaded the scribe module as:\nlocal scribe = require 'scribe'\nThen, you have several functions for turning Lua objects into strings.\nThe methods vary by the way they present Lua tables. Assuming you haven’t altered the defaults as outlined in scribe.options then:\n\n\n\n\n\n\n\n\nMethod\nReturned String\n\n\n\n\nscribe.inline(obj)\nA one-line string.  Arrays are delimited using square brackets [ ... ].  Other tables are delimited using curly braces { ... }.\n\n\nscribe.pretty(obj)\nA “pretty”, generally multiline, string for tables.  Arrays are delimited using square brackets [ ... ].  Other tables are delimited using curly braces { ... }.  Simple tables & arrays with no nesting are shown on one line.\n\n\nscribe.classic(obj)\nA “classic” multiline format where elements are on their line.  Tables and arrays are delimited using curly braces { ... }.\n\n\nscribe.alt(obj)\nAn alternate multiline string for tables without delimiters.  Table structure is shown by indentation.\n\n\nscribe.json(obj)\nA multiline JSON string for tables.\n\n\nscribe.inline_json(obj)\nA compact one-line JSON string for tables.\n\n\nscribe.debug(obj)\nA string that exposes the structure of a table.\n\n\nscribe.scribe(obj, opts)\nParent function used by the other methods.  Converts obj to a string based on the opts formatting table.\n\n\n\n\nThese methods are drop-in replacements for the standard Lua tostring function. They return a reasonable string for any Lua object.\nThe methods differ in how they format Lua tables as strings. The first nine methods call on the final scribe.scribe(obj, options) with different values for the options argument. See the Standard Options page for details on the specific formatting values.\n\n    \n     \n    \n    \nInstead of calling scribe.scribe(obj, opts) you can call scribe(obj, opts). The second argument is optional. If it’s missing, we pass a default set of formatting options. Out of the box, those default options are the same as those used to produce one-line strings.\n\n\n    \n     \n    \n    \nThe only complex native Lua type is a table. In Lua, arrays are tables where the keys are successive integers starting at 1. Scribe has several output methods that mark arrays with different delimiters—by default, [ ... ] versus { ... }.",
    "crumbs": [
      "Home",
      "Stringification"
    ]
  },
  {
    "objectID": "pages/stringification.html#introduction",
    "href": "pages/stringification.html#introduction",
    "title": "Converting Lua Objects to Strings",
    "section": "",
    "text": "If you have loaded the scribe module as:\nlocal scribe = require 'scribe'\nThen, you have several functions for turning Lua objects into strings.\nThe methods vary by the way they present Lua tables. Assuming you haven’t altered the defaults as outlined in scribe.options then:\n\n\n\n\n\n\n\n\nMethod\nReturned String\n\n\n\n\nscribe.inline(obj)\nA one-line string.  Arrays are delimited using square brackets [ ... ].  Other tables are delimited using curly braces { ... }.\n\n\nscribe.pretty(obj)\nA “pretty”, generally multiline, string for tables.  Arrays are delimited using square brackets [ ... ].  Other tables are delimited using curly braces { ... }.  Simple tables & arrays with no nesting are shown on one line.\n\n\nscribe.classic(obj)\nA “classic” multiline format where elements are on their line.  Tables and arrays are delimited using curly braces { ... }.\n\n\nscribe.alt(obj)\nAn alternate multiline string for tables without delimiters.  Table structure is shown by indentation.\n\n\nscribe.json(obj)\nA multiline JSON string for tables.\n\n\nscribe.inline_json(obj)\nA compact one-line JSON string for tables.\n\n\nscribe.debug(obj)\nA string that exposes the structure of a table.\n\n\nscribe.scribe(obj, opts)\nParent function used by the other methods.  Converts obj to a string based on the opts formatting table.\n\n\n\n\nThese methods are drop-in replacements for the standard Lua tostring function. They return a reasonable string for any Lua object.\nThe methods differ in how they format Lua tables as strings. The first nine methods call on the final scribe.scribe(obj, options) with different values for the options argument. See the Standard Options page for details on the specific formatting values.\n\n    \n     \n    \n    \nInstead of calling scribe.scribe(obj, opts) you can call scribe(obj, opts). The second argument is optional. If it’s missing, we pass a default set of formatting options. Out of the box, those default options are the same as those used to produce one-line strings.\n\n\n    \n     \n    \n    \nThe only complex native Lua type is a table. In Lua, arrays are tables where the keys are successive integers starting at 1. Scribe has several output methods that mark arrays with different delimiters—by default, [ ... ] versus { ... }.",
    "crumbs": [
      "Home",
      "Stringification"
    ]
  },
  {
    "objectID": "pages/stringification.html#optional-overrides",
    "href": "pages/stringification.html#optional-overrides",
    "title": "Converting Lua Objects to Strings",
    "section": "Optional Overrides",
    "text": "Optional Overrides\nThe scribe method can also take an extra optional argument overrides:\nscribe(obj, options, overrides)\nThe options table is the primary set of formatting options used to display table objects. The optional overrides argument can tweak any field in that main set. If present, it should be a table. We extract any valid scribe.options field from it instead of the one in options.\nAll the other methods above can also be passed overrides as an optional argument.\nFor example:\nscribe.inline(obj, overrides)\nis the same as the call:\nscribe(obj, scribe.options.inline, overrides)\nSuppose you wish to delimit inline arrays with parentheses. You can achieve that by passing some overrides in a table to scribe.inline:\nlocal my_options = { array_begin = '(', array_end = ')'}\nlocal fruits = {'Apple', 'Pear', 'Banana'}\nprint(scribe.inline(fruits, my_options))\nThis returns the string ( \"Apple\", \"Pear\", \"Banana\" ).\nOn return, you can now use my_options as a completely independent set of formatting options. It will have been filled out with all the needed fields from, in this case, scribe.options.inline. To see that we can pretty print it!\nputln(\"my_options: %2T\", my_options)`\nyields:\nmy_options: {\n    COMPLETE = true,\n1    array_begin = \"(\",\n    array_end = \")\",\n    comparator = &lt;function&gt;,\n    indent = \"\",\n2    inline_size = inf,\n    inline_spacer = \" \",\n    key_begin = \"\",\n    key_end = \" = \",\n    path_begin = \"&lt;\",\n    path_end = \"&gt;\",\n    path_root = \"table\",\n    path_sep = \".\",\n    sep = \",\",\n    show_indices = false,\n    table_begin = \"{\",\n    table_end = \"}\",\n    use_metatable = true\n}\n\n1\n\nThe array_begin and array_end fields have been set to ( and ) respectively.\n\n2\n\ninf is a special value that means “infinity” accessible in Lua via math.huge.\n\n\nThis means you could now completely replace scribe.options.inline if you wish by setting:\nscribe.options.inline = my_options\nThen putln(\"Fruits: %t\", fruits) returns Fruits: ( \"Apple\", \"Pear\", \"Banana\" ).\n\n    \n     \n    \n    \nOn return, the overrides argument will be expanded to include all the non-customised fields from the options table, which it overrides.",
    "crumbs": [
      "Home",
      "Stringification"
    ]
  },
  {
    "objectID": "pages/stringification.html#optional-name",
    "href": "pages/stringification.html#optional-name",
    "title": "Converting Lua Objects to Strings",
    "section": "Optional Name",
    "text": "Optional Name\nThe first seven methods above all can take an extra optional string argument. If present, we assume that it is a name you wish to embed in the returned string.\nFor example, the whole calling sequence for scribe.inline is:\nscribe.inline(obj, overrides, name)\nThe final two arguments are optional.\nAssuming overrides is a table and name is a string, then any of the following calls are valid:\nscribe.inline(obj)\nscribe.inline(obj, overrides)\nscribe.inline(obj, name)\nscribe.inline(obj, overrides, name)\nscribe.inline(obj, name, overrides)\nFor the non-JSON methods, if the name argument is present, it just gets prepended to the returned string.\nprint(scribe.inline(fruits, \"Fruits: \"))\nreturns the string Fruits: [ \"Apple\", \"Pear\", \"Banana\"  ].\nFor the two JSON conversions, we assume you wish to “embed” the name in a JSON-like manner:\nprint(scribe.json(fruits, \"Fruits\"))\nreturns\n{\"Fruits\": [\n    \"Apple\",\n    \"Pear\",\n    \"Banana\"\n]}",
    "crumbs": [
      "Home",
      "Stringification"
    ]
  },
  {
    "objectID": "pages/stringification.html#examples-array",
    "href": "pages/stringification.html#examples-array",
    "title": "Converting Lua Objects to Strings",
    "section": "Examples: Array",
    "text": "Examples: Array\nWe look at how each of those methods outputs a simple array.\nSimple Array Input\nlocal fruits = {'Apple', 'Pear', 'Banana'}\nprint(scribe.inline(fruits,        'Inline Format:\\n'),        '\\n')\nprint(scribe.pretty(fruits,        'Pretty Format:\\n'),        '\\n')\nprint(scribe.classic(fruits,       'Classic Format:\\n'),       '\\n')\nprint(scribe.alt(fruits,           'Alt Format:\\n'),           '\\n')\nprint(scribe.inline_json(fruits,   'Inline-JSON-Format'),      '\\n')\nprint(scribe.json(fruits,          'JSON-Format'),             '\\n')\nSimple Array Output\nInline Format:\n1[ \"Apple\", \"Pear\", \"Banana\" ]\n\nPretty Format:\n2[ \"Apple\", \"Pear\", \"Banana\" ]\n\n3Classic Format:\n{\n    \"Apple\",\n    \"Pear\",\n    \"Banana\"\n}\n\n4Alt Format:\n    \"Apple\", \"Pear\", \"Banana\",\n\"Apple\",\n\"Pear\",\n\"Banana\"\n\n5{\"Inline-JSON-Format\": [\"Apple\",\"Pear\",\"Banana\"]}\n\n6{\"JSON-Format\": [\n    \"Apple\",\n    \"Pear\",\n    \"Banana\"\n]}\n\n1\n\nThe table is printed on a single line using square bracket delimiters because fruits is an array.\n\n2\n\nThe table is “simple” with no nested sub-tables, so the pretty output is still on a single line.\n\n3\n\nThe “classic” format puts everything on its line and uses brace delimiters and indentation.\n\n4\n\nThe alternate multiline output doesn’t use table delimiters and doesn’t need indentation in this simple case.\n\n5\n\nJSON always uses square braces to delimit arrays.  The inline version avoids white space as much as possible.\n\n6\n\nThis is a classic JSON multiline string for an array of values.",
    "crumbs": [
      "Home",
      "Stringification"
    ]
  },
  {
    "objectID": "pages/stringification.html#example-linked-list",
    "href": "pages/stringification.html#example-linked-list",
    "title": "Converting Lua Objects to Strings",
    "section": "Example: Linked List",
    "text": "Example: Linked List\nLet’s look at how some of the same methods output a “linked list”:\nLinked List Input\nlocal list = {p1 = {name = 'Alice'}, p2 = {name = 'Maria'}}\nlist.p1.next = list.p2\nlist.p2.prev = list.p1\n\nprint(scribe.inline(list,  'Inline Format:\\n'), '\\n')\nprint(scribe.pretty(list,  'Pretty Format:\\n'), '\\n')\nprint(scribe.alt(list,     'Alt Format:\\n'),    '\\n')\nprint(scribe.classic(list, 'Classic Format:\\n'))\nLinked List Output\nInline Format:\n1{ p1 = { name = \"Alice\", next = &lt;p2&gt; }, p2 = { name = \"Maria\", prev = &lt;p1&gt; } }\n\nPretty Format:\n{\n    p1 = {\n        name = \"Alice\",\n        next = &lt;p2&gt;\n    },\n    p2 = {\n        name = \"Maria\",\n        prev = &lt;p1&gt;\n    }\n}\n\nAlt Format:\np1:\n    name: \"Alice\",\n    next: &lt;p2&gt;,\np2:\n    name: \"Maria\",\n    prev: &lt;p1&gt;\n\nClassic Format:\n{\n    p1 = {\n        name = \"Alice\",\n        next = &lt;p2&gt;\n    },\n    p2 = {\n        name = \"Maria\",\n        prev = &lt;p1&gt;\n    }\n}\n\n1\n\nThe table is printed on a single line. Path references show shared tables.",
    "crumbs": [
      "Home",
      "Stringification"
    ]
  },
  {
    "objectID": "pages/stringification.html#another-example",
    "href": "pages/stringification.html#another-example",
    "title": "Converting Lua Objects to Strings",
    "section": "Another Example",
    "text": "Another Example\nWe look at the output for a doubly linked list.\nDoubly Linked List Input\nlocal a = { node = 'Thomas', payload = 10 }\nlocal b = { node = 'Harold', payload = 20 }\nlocal c = { node = 'Sloane', payload = 30 }\nlocal d = { node = 'Daphne', payload = 40 }\n\na.next, b.next, c.next, d.next = b, c, d, d\na.prev, b.prev, c.prev, d.prev = a, a, b, c\nlocal linked_list = { a, b, c, d }\n\nprint(scribe.pretty(linked_list, \"Pretty Format:\\n\"), '\\n')\nprint(scribe.alt(linked_list,    \"Alt Format:\\n\"), '\\n')\nDoubly Linked List Output\nPretty Format:\n[\n    1 = { next = &lt;2&gt;, node = \"Thomas\", payload = 10, prev = &lt;1&gt; },\n    2 = { next = &lt;3&gt;, node = \"Harold\", payload = 20, prev = &lt;1&gt; },\n    3 = { next = &lt;4&gt;, node = \"Sloane\", payload = 30, prev = &lt;2&gt; },\n    4 = { next = &lt;4&gt;, node = \"Daphne\", payload = 40, prev = &lt;3&gt; }\n]\n\n\nAlt Format:\n1:\n    next: &lt;2&gt;,\n    node: \"Thomas\",\n    payload: 10,\n    prev: &lt;1&gt;,\n2:\n    next: &lt;3&gt;,\n    node: \"Harold\",\n    payload: 20,\n    prev: &lt;1&gt;,\n3:\n    next: &lt;4&gt;,\n    node: \"Sloane\",\n    payload: 30,\n    prev: &lt;2&gt;,\n4:\n    next: &lt;4&gt;,\n    node: \"Daphne\",\n    payload: 40,\n    prev: &lt;3&gt;\nNote that the array elements are shown inline in the pretty output. Those elements are simple tables with no nested sub-tables; the embedded next and prev fields reference other tables and do not count as sub-tables.\nThe alt output shows the array elements on separate lines.\nBecause we have cycles and references, we show all the array indices.",
    "crumbs": [
      "Home",
      "Stringification"
    ]
  },
  {
    "objectID": "pages/stringification.html#see-also",
    "href": "pages/stringification.html#see-also",
    "title": "Converting Lua Objects to Strings",
    "section": "See Also",
    "text": "See Also\nFormatting Options  Standard Options  Customising Options  Output Methods  Turning the Tables …",
    "crumbs": [
      "Home",
      "Stringification"
    ]
  },
  {
    "objectID": "pages/standard-formats.html",
    "href": "pages/standard-formats.html",
    "title": "Pre-canned “Standard” Formatting Options",
    "section": "",
    "text": "Scribe provides pre-canned sets of formatting options used to output tables in various “standard” ways:\n\n\n\n\n\n\n\n\nOption Table\nCorresponding Method\n\n\n\n\nscribe.options.inline\nscribe.inline\n\n\nscribe.options.pretty\nscribe.pretty\n\n\nscribe.options.classic\nscribe.classic\n\n\nscribe.options.alt\nscribe.alt\n\n\nscribe.options.json\nscribe.json\n\n\nscribe.options.inline_json\nscribe.inline_json\n\n\nscribe.options.debug\nscribe.debug\n\n\nscribe.options.default\nThe default options to use for calls like scribe(obj)\n\n\n\n\nThe detailed settings for each of the option tables are documented below.\nYou can also use the scribe.clone method to copy one of these standard options tables and tweak it to get the desired output style for your use case.\nlocal my_pretty_options = scribe.clone(scribe.options.pretty)\n1my_pretty_options.indent = \"  \"\n\n1\n\nThis will change the indentation to two spaces instead of four.",
    "crumbs": [
      "Home",
      "Standard Formats"
    ]
  },
  {
    "objectID": "pages/standard-formats.html#introduction",
    "href": "pages/standard-formats.html#introduction",
    "title": "Pre-canned “Standard” Formatting Options",
    "section": "",
    "text": "Scribe provides pre-canned sets of formatting options used to output tables in various “standard” ways:\n\n\n\n\n\n\n\n\nOption Table\nCorresponding Method\n\n\n\n\nscribe.options.inline\nscribe.inline\n\n\nscribe.options.pretty\nscribe.pretty\n\n\nscribe.options.classic\nscribe.classic\n\n\nscribe.options.alt\nscribe.alt\n\n\nscribe.options.json\nscribe.json\n\n\nscribe.options.inline_json\nscribe.inline_json\n\n\nscribe.options.debug\nscribe.debug\n\n\nscribe.options.default\nThe default options to use for calls like scribe(obj)\n\n\n\n\nThe detailed settings for each of the option tables are documented below.\nYou can also use the scribe.clone method to copy one of these standard options tables and tweak it to get the desired output style for your use case.\nlocal my_pretty_options = scribe.clone(scribe.options.pretty)\n1my_pretty_options.indent = \"  \"\n\n1\n\nThis will change the indentation to two spaces instead of four.",
    "crumbs": [
      "Home",
      "Standard Formats"
    ]
  },
  {
    "objectID": "pages/standard-formats.html#example-setup",
    "href": "pages/standard-formats.html#example-setup",
    "title": "Pre-canned “Standard” Formatting Options",
    "section": "Example Setup",
    "text": "Example Setup\nWe will use some sample tables below.\nA simple array of values:\nlocal fruits = {'Apple', 'Pear', 'Banana'}\nA trivial “linked list” with a spurious self-reference under the list.all key:\nlocal list = { person1 = { name = 'Alice' }, person2 = { name = 'Beth' } }\nlist.person1.next = list.person2\nlist.person2.prev = list.person1\nlist.all = list\nAnd finally, a table of the sort that might arise in an actual application:\nlocal user_profile = {\n    name = \"Bill\",\n    preferences = {\n        notifications = \"enabled\",\n        privacy = {\n            share_location = false,\n            online_status  = \"invisible\"\n        }\n    },\n    friends = { \"Tom\", \"Dick\", \"Harry\" }\n}",
    "crumbs": [
      "Home",
      "Standard Formats"
    ]
  },
  {
    "objectID": "pages/standard-formats.html#inline-options",
    "href": "pages/standard-formats.html#inline-options",
    "title": "Pre-canned “Standard” Formatting Options",
    "section": "Inline Options",
    "text": "Inline Options\nThis set of formatting options is used when you call scribe.inline(tbl).\nIt can be accessed as scribe.options.inline if you want to change a value.\n\n\n\n\n\n\n\n\nOption\nValue\n\n\n\n\nindent\n\"\"\n\n\ntable_begin\n{\n\n\ntable_end\n}\n\n\narray_begin\n[\n\n\narray_end\n]\n\n\ninline_spacer\n\" \"\n\n\nkey_begin\n\"\"\n\n\nkey_end\n\" = \"\n\n\nshow_indices\nfalse\n\n\nsep\n,\n\n\ninline_size\nmath.huge\n\n\ncomparator\nDefault sorts keys by type and value.\n\n\nuse_metatable\ntrue\n\n\npath_root\n\"table\"\n\n\npath_sep\n.\n\n\npath_begin\n&lt;\n\n\npath_end\n&gt;\n\n\n\n\n\n    \n     \n    \n    \nThe thing that makes this produce one-line strings is the fact that the indent value is the empty string. Doing that will consistently produce table strings on a single line.\n\nFor our examples above:\nprint(\"Inline Fruits:\")\nprint(scribe.inline(fruits), '\\n')\nprint(\"Inline User Profile:\")\nprint(scribe.inline(user_profile),  '\\n')\nprint(\"Inline Linked List:\")\nprint(scribe.inline(list))\nWe get the outputs:\nInline Fruits:\n[ \"Apple\", \"Pear\", \"Banana\" ]\n\nInline User Profile:\n{ friends = [ \"Tom\", \"Dick\", \"Harry\" ], name = \"Bill\", preferences = { notifications = \"enabled\", privacy = { online_status = \"invisible\", share_location = false } } }\n\nInline Linked List:\n&lt;table&gt; = { all = &lt;table&gt;, person1 = { name = \"Alice\", next = &lt;person2&gt; }, person2 = { name = \"Beth\", prev = &lt;person1&gt; } }\nfruits is shown as a simple array in the numeric order of the indices in the array. The indices themselves aren’t shown.\nThe linked list is also on one line. It uses paths for self-references like list.all = &lt;table&gt; where &lt;table&gt; refers to the list itself. Similarly, we see that list.person1.next = &lt;person2&gt;",
    "crumbs": [
      "Home",
      "Standard Formats"
    ]
  },
  {
    "objectID": "pages/standard-formats.html#pretty-options",
    "href": "pages/standard-formats.html#pretty-options",
    "title": "Pre-canned “Standard” Formatting Options",
    "section": "Pretty Options",
    "text": "Pretty Options\nThis is the set of formatting options used when you call scribe.pretty(tbl).\nIt is a clone of scribe.options.inline,, except that the indent field is four spaces. It can be accessed as scribe.options.pretty if you want to change a field.\n\n    \n     \n    \n    \nAny non-empty indent field value will produce multiline output.\n\nAll arrays are indented elements surrounded by square brackets. Other tables are indented elements surrounded by curly braces. However, simple tables and arrays are still displayed on a single line.\nFor our simplest array example:\nprint(scribe.pretty(fruits))\nwe get the inline output:\n[ \"Apple\", \"Pear\", \"Banana\" ]\nThe fruits table is simple without any nested sub-tables or sub-arrays.\nFor the more complex linked list case:\nprint(scribe.pretty(list))\nWe get the output:\n&lt;table&gt; = {\n    all = &lt;table&gt;,\n    person1 = {\n        name = \"Alice\",\n        next = &lt;person2&gt;\n    },\n    person2 = {\n        name = \"Beth\",\n        prev = &lt;person1&gt;\n    }\n}",
    "crumbs": [
      "Home",
      "Standard Formats"
    ]
  },
  {
    "objectID": "pages/standard-formats.html#classic-options",
    "href": "pages/standard-formats.html#classic-options",
    "title": "Pre-canned “Standard” Formatting Options",
    "section": "Classic Options",
    "text": "Classic Options\nIt is so named because it produces the typical look from many table-to-string conversion functions. Braces surround tables, and their elements are on separate lines, with the structure emphasised with indentation.\nEven our trivial array will get output on multiple lines from print(scribe.classic(fruits)):\n{\n    \"Apple\",\n    \"Pear\",\n    \"Banana\"\n}\nThis option set is a clone of scribe.options.inline, except that the indent field is four spaces and inline_size field is 0 so we never inline simple tables.\nIt can be accessed as scribe.options.classic if you want to change a field.\nFrom print(scribe.classic(user_profile)), we get:\n{\n    friends = {\n        \"Tom\",\n        \"Dick\",\n        \"Harry\"\n    },\n    name = \"Bill\",\n    preferences = {\n        notifications = \"enabled\",\n        privacy = {\n            online_status = \"invisible\",\n            share_location = false\n        }\n    }\n}",
    "crumbs": [
      "Home",
      "Standard Formats"
    ]
  },
  {
    "objectID": "pages/standard-formats.html#alt-options",
    "href": "pages/standard-formats.html#alt-options",
    "title": "Pre-canned “Standard” Formatting Options",
    "section": "Alt Options",
    "text": "Alt Options\nThis is the set of formatting options used when you call scribe.alt(tbl). The output is multiline, where all table and array structures are shown solely by indentation. There are no array or table delimiters.\nIt can be accessed as scribe.options.alt if you want to change a value.\n\n\n\n\n\n\n\n\nOption\nValue\n\n\n\n\nindent\n\"    \"\n\n\ntable_begin\n\"\"\n\n\ntable_end\n\"\"\n\n\narray_begin\n\"\"\n\n\narray_end\n\"\"\n\n\ninline_spacer\n\"\"\n\n\nkey_begin\n\"'\"\n\n\nkey_end\n\": \",\n\n\nshow_indices\nfalse\n\n\nsep\n,\n\n\ninline_size\n0\n\n\ncomparator\nDefault sorts keys by type and value.\n\n\nuse_metatable\ntrue\n\n\npath_root\ntable\n\n\npath_sep\n.\n\n\npath_begin\n&lt;\n\n\npath_end\n&gt;\n\n\n\n\nFor our simple example:\nprint(scribe.alt(fruits))\nWe get the output:\n\"Apple\", \"Pear\", \"Banana\"\nFor the more complex linked list:\nprint(scribe.alt(list))\nWe get the output:\n&lt;table&gt; = all: &lt;table&gt;,\nperson1:\n    name: \"Alice\",\n    next: &lt;person2&gt;,\nperson2:\n    name: \"Beth\",\n    prev: &lt;person1&gt;",
    "crumbs": [
      "Home",
      "Standard Formats"
    ]
  },
  {
    "objectID": "pages/standard-formats.html#json-options",
    "href": "pages/standard-formats.html#json-options",
    "title": "Pre-canned “Standard” Formatting Options",
    "section": "JSON Options",
    "text": "JSON Options\nScribe uses formatting options to tweak the string output for tables.\nAdding JSON output was just a matter of creating scribe.options.json:\n\n\n\n\n\n\n\n\nOption\nValue\n\n\n\n\nindent\n\"    \"\n\n\ntable_begin\n{\n\n\ntable_end\n}\n\n\narray_begin\n[\n\n\narray_end\n]\n\n\nextra_space\n\" \"\n\n\nkey_begin\n'\"'\n\n\nkey_end\n'\": '\n\n\narray_keys\nfalse\n\n\nsep\n,\n\n\ninline_size\n0\n\n\ncomparator\nDefault sorts keys by type and value.\n\n\nuse_metatable\ntrue\n\n\npath_root\ntable\n\n\npath_sep\n.\n\n\npath_begin\n&lt;\n\n\npath_end\n&gt;\n\n\n\n\nJSON distinguishes between arrays shown as [ ... ] and non-arrays shown as { ... }. It also surrounds keys with double quotes.\nFrom print(scribe.json(user_profile)) we get:\n{\n1    \"friends\": [\n        \"Tom\",\n        \"Dick\",\n        \"Harry\"\n    ],\n    \"name\": \"Bill\",\n    \"preferences\": {\n        \"notifications\": \"enabled\",\n        \"privacy\": {\n            \"online_status\": \"invisible\",\n            \"share_location\": false\n        }\n    }\n}\n\n1\n\nUnlike the other non-array tables, the friends array is surrounded by square brackets.",
    "crumbs": [
      "Home",
      "Standard Formats"
    ]
  },
  {
    "objectID": "pages/standard-formats.html#inline-json-options",
    "href": "pages/standard-formats.html#inline-json-options",
    "title": "Pre-canned “Standard” Formatting Options",
    "section": "Inline JSON Options",
    "text": "Inline JSON Options\nWe also supply scribe.options.inline_json, which is similar except that the indent field is the empty string, so the output will always be on a single line.\nIt also tweaks the delimiters to minimise the use of white space.\nFrom print(scribe.inline_json(user_profile)), we get:\n{\"friends\":[\"Tom\",\"Dick\",\"Harry\"],\"name\":\"Bill\",\"preferences\":{\"notifications\":\"enabled\",\"privacy\":{\"online_status\":\"invisible\",\"share_location\":false}}}\nThis isn’t all that readable, but it is as compact as possible and still follows JSON format guidelines.",
    "crumbs": [
      "Home",
      "Standard Formats"
    ]
  },
  {
    "objectID": "pages/standard-formats.html#debug-options",
    "href": "pages/standard-formats.html#debug-options",
    "title": "Pre-canned “Standard” Formatting Options",
    "section": "Debug Options",
    "text": "Debug Options\nThis is the set of formatting options used when you call scribe.debug(tbl). It gives you a sense of how scribe views the internal structure of a table. It is not designed for everyday use but is useful when tweaking a custom set of formatting options.\nIt can be accessed as scribe.options.debug if you want to change a value.\n\n\n\n\n\n\n\n\nOption\nValue\n\n\n\n\nindent\n' INDENT '\n\n\ntable_begin\n'TABLE_BEGIN'\n\n\ntable_end\n'TABLE_END'\n\n\narray_begin\n'ARRAY_BEGIN'\n\n\narray_end\n'ARRAY_END'\n\n\ninline_spacer\n' '\n\n\nkey_left\n'KEY_BEGIN \"'\n\n\nkey_right\n'\" KEY_END = '\n\n\nshow_indices\ntrue\n\n\nsep\n' SEP '\n\n\ninline_size\n0\n\n\ncomparator\nDefault sorts keys by type and value.\n\n\nuse_metatable\ntrue\n\n\npath_root\ntable\n\n\npath_sep\n.\n\n\npath_begin\n&lt;\n\n\npath_end\n&gt;\n\n\n\n\nFor our simple example:\nprint(scribe.debug(fruits))\nWe get the output:\nARRAY_BEGIN\n INDENT  KEY_BEGIN \"1\" KEY_END = \"Apple\" SEP\n INDENT  KEY_BEGIN \"2\" KEY_END = \"Pear\" SEP\n INDENT  KEY_BEGIN \"3\" KEY_END = \"Banana\"\nARRAY_END\nARRAY_BEGIN\n INDENT  KEY_BEGIN \"1\" KEY_END = \"Apple\" SEP\n INDENT  KEY_BEGIN \"2\" KEY_END = \"Pear\" SEP\n INDENT  KEY_BEGIN \"3\" KEY_END = \"Banana\"\nARRAY_END\nFor the more complex case:\nprint(scribe.debug(list))\nWe get the output:\n&lt;table&gt; = TABLE_BEGIN\n INDENT  KEY_BEGIN \"all\" KEY_END = &lt;table&gt; SEP\n INDENT  KEY_BEGIN \"person1\" KEY_END = TABLE_BEGIN\n INDENT  INDENT  KEY_BEGIN \"name\" KEY_END = \"Alice\" SEP\n INDENT  INDENT  KEY_BEGIN \"next\" KEY_END = &lt;person2&gt;\n INDENT TABLE_END SEP\n INDENT  KEY_BEGIN \"person2\" KEY_END = TABLE_BEGIN\n INDENT  INDENT  KEY_BEGIN \"name\" KEY_END = \"Beth\" SEP\n INDENT  INDENT  KEY_BEGIN \"prev\" KEY_END = &lt;person1&gt;\n INDENT TABLE_END\nTABLE_END\nTables, key-value pairs, and keys are all shown with explicit tokens for their start and end.\nWe note that while there are some added newlines, you would still need to tweak this output in an editor to make it worthwhile.",
    "crumbs": [
      "Home",
      "Standard Formats"
    ]
  },
  {
    "objectID": "pages/standard-formats.html#default-options",
    "href": "pages/standard-formats.html#default-options",
    "title": "Pre-canned “Standard” Formatting Options",
    "section": "Default Options",
    "text": "Default Options\nThis is the set of options used when you call scribe(tbl) without any second argument. By default, this is scribe.options.inline, which means scribe(tbl) returns a one-line string representation of tbl.\nYou can change that to, say, a multiline string for all tables by:\n scribe.options.default = scribe.options.pretty",
    "crumbs": [
      "Home",
      "Standard Formats"
    ]
  },
  {
    "objectID": "pages/standard-formats.html#see-also",
    "href": "pages/standard-formats.html#see-also",
    "title": "Pre-canned “Standard” Formatting Options",
    "section": "See Also",
    "text": "See Also\nFormatting Options  Custom Options  Object-to-String Conversions  Formatted Output  Turning the Tables …",
    "crumbs": [
      "Home",
      "Standard Formats"
    ]
  },
  {
    "objectID": "pages/formatted-output.html",
    "href": "pages/formatted-output.html",
    "title": "Formatted Output",
    "section": "",
    "text": "Scribe has functions to create and print formatted strings.\nThe functions build on Lua’s string.format capabilities by adding extra format specifiers for Lua tables.\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\nscribe.format(fmt,...)\nBuilds a string from a template fmt along with trailing values that fill the placeholders in fmt.\n\n\nscribe.put(fmt,...)\nWrites a formatted string from scribe.format to stdout.\n\n\nscribe.putln(fmt,...)\nWrites a formatted string followed by a newline to stdout.\n\n\nscribe.eput(fmt,...)\nWrites a formatted string to stderr.\n\n\nscribe.eput(fmt,...)\nWrites a formatted string followed by a newline to stderr.\n\n\nscribe.fput(f, fmt,...)\nWrites a formatted string to the file f.\n\n\nscribe.fput(f, fmt,...)\nWrites a formatted string followed by a newline to the file f.\n\n\n\n\nThe scribe.format(fmt, ...) method extends Lua’s standard string.format(fmt, ...). If the fmt “recipe” doesn’t have any of Scribe’s custom table specifiers, then the two methods produce identical results.\nLua’s standard string.format method is based almost entirely on the time-tested [sprintf] function from C. You can use string.format to do things like:\nlocal name, age = \"Johnny\", 11\nlocal greeting = string.format(\"Hi, my name is %s, and I am %d years old!\", name, age)\nprint(greeting)\nThis prints “Hi, my name is Johnny, and I am 11 years old!” on the screen.\nThe template \"Hi, my name is %s and I am %d years old!\" can be viewed as a recipe for making strings. The %s and %d format specifiers are placeholders and tell string.format to look for two variables in the trailing arguments and to format the first as a string and the second as a decimal number. If you don’t pass two appropriate trailing parameters after the template, string.format will be upset and raise an error.\nBeyond the most trivial scripts, Lua programs are chock full of tables. A considerable drawback of string.format is that it does not know how to format a Lua table usefully. The underlying C mechanism it relies on is oblivious to its internals.\nAt best, given a table argument, string.format will pop out something like “table:x600001d32980”, which can be interpreted as Lua saying, “Yes, I see a table, and it resides at that long hexadecimal address in memory”. That is very unlikely to be what you want.\nOf course, the string.format function is still very valuable. But to use it, you really need to unpack any table arguments into their constituent non-table elements. While this is always possible, it is ungainly and time-consuming.\nThe scribe.format function fixes the gap by adding extra placeholder specifiers that let you output tables in several styles. When scribe.format comes across %t in a recipe template, it expects there is a corresponding table argument that you want to see as an inline table. The actual conversion of the table to a string is then done by scribe.inline.",
    "crumbs": [
      "Home",
      "Formatted Output"
    ]
  },
  {
    "objectID": "pages/formatted-output.html#introduction",
    "href": "pages/formatted-output.html#introduction",
    "title": "Formatted Output",
    "section": "",
    "text": "Scribe has functions to create and print formatted strings.\nThe functions build on Lua’s string.format capabilities by adding extra format specifiers for Lua tables.\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\nscribe.format(fmt,...)\nBuilds a string from a template fmt along with trailing values that fill the placeholders in fmt.\n\n\nscribe.put(fmt,...)\nWrites a formatted string from scribe.format to stdout.\n\n\nscribe.putln(fmt,...)\nWrites a formatted string followed by a newline to stdout.\n\n\nscribe.eput(fmt,...)\nWrites a formatted string to stderr.\n\n\nscribe.eput(fmt,...)\nWrites a formatted string followed by a newline to stderr.\n\n\nscribe.fput(f, fmt,...)\nWrites a formatted string to the file f.\n\n\nscribe.fput(f, fmt,...)\nWrites a formatted string followed by a newline to the file f.\n\n\n\n\nThe scribe.format(fmt, ...) method extends Lua’s standard string.format(fmt, ...). If the fmt “recipe” doesn’t have any of Scribe’s custom table specifiers, then the two methods produce identical results.\nLua’s standard string.format method is based almost entirely on the time-tested [sprintf] function from C. You can use string.format to do things like:\nlocal name, age = \"Johnny\", 11\nlocal greeting = string.format(\"Hi, my name is %s, and I am %d years old!\", name, age)\nprint(greeting)\nThis prints “Hi, my name is Johnny, and I am 11 years old!” on the screen.\nThe template \"Hi, my name is %s and I am %d years old!\" can be viewed as a recipe for making strings. The %s and %d format specifiers are placeholders and tell string.format to look for two variables in the trailing arguments and to format the first as a string and the second as a decimal number. If you don’t pass two appropriate trailing parameters after the template, string.format will be upset and raise an error.\nBeyond the most trivial scripts, Lua programs are chock full of tables. A considerable drawback of string.format is that it does not know how to format a Lua table usefully. The underlying C mechanism it relies on is oblivious to its internals.\nAt best, given a table argument, string.format will pop out something like “table:x600001d32980”, which can be interpreted as Lua saying, “Yes, I see a table, and it resides at that long hexadecimal address in memory”. That is very unlikely to be what you want.\nOf course, the string.format function is still very valuable. But to use it, you really need to unpack any table arguments into their constituent non-table elements. While this is always possible, it is ungainly and time-consuming.\nThe scribe.format function fixes the gap by adding extra placeholder specifiers that let you output tables in several styles. When scribe.format comes across %t in a recipe template, it expects there is a corresponding table argument that you want to see as an inline table. The actual conversion of the table to a string is then done by scribe.inline.",
    "crumbs": [
      "Home",
      "Formatted Output"
    ]
  },
  {
    "objectID": "pages/formatted-output.html#table-format-specifiers",
    "href": "pages/formatted-output.html#table-format-specifiers",
    "title": "Formatted Output",
    "section": "Table Format Specifiers",
    "text": "Table Format Specifiers\nAs well as all the usual Lua format specifiers like %s for strings after importing scribe, Scribe recognises these extra ones to deal with tables.\n\n\n\n\n\n\n\n\nSpecifier\nOutput from the Corresponding Table Argument\n\n\n\n\n%t\nA one-line string.  Arrays are delimited as [ ... ].  Other tables are delimited as { ... }.\n\n\n%T\nA pretty, multi-line string.  Arrays are delimited as [ ... ].  Other tables are delimited as { ... }.  Simple tables with no sub-tables are still inlined.\n\n\n%2T\nA “classic” multi-line string with tables in braces and all elements on separate indented lines.\n\n\n%3T\nA multi-line string without delimiters that shows the table structure by indentation alone.\n\n\n%9T\nA debug string showing the table structure in an abstract syntax tree.\n\n\n%J\nA multiline JSON string.\n\n\n%j\nA compact one-line JSON string.\n\n\n\n\nExample:\nlocal putln = require('scribe').putln\nlocal pupils = {{name = 'Mary', age = 12}, {name = 'Joe', age = 11}}\nputln(\"Our pupils: %t\", pupils)\nOutput:\nOur pupils: [ { age = 12, name = \"Mary\" }, { age = 11, name = \"Joe\" } ]",
    "crumbs": [
      "Home",
      "Formatted Output"
    ]
  },
  {
    "objectID": "pages/formatted-output.html#class-extensions",
    "href": "pages/formatted-output.html#class-extensions",
    "title": "Formatted Output",
    "section": "Class Extensions",
    "text": "Class Extensions\nScribe also adds some methods to Lua’s file and string classes.\nIf f is a Lua file handle, and s is a Lua string, then after loading scribe you have access to the following new class methods:\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\nf:put(fmt, ...)\nThis is another way of writing scribe.fput(f, fmt, ...).\n\n\nf:putln(fmt, ...)\nThis is another way of writing scribe.fputln(f, fmt, ...).\n\n\ns:scribe(...)\nThis is another way of writing scribe.format(s, ...).",
    "crumbs": [
      "Home",
      "Formatted Output"
    ]
  },
  {
    "objectID": "pages/formatted-output.html#errors",
    "href": "pages/formatted-output.html#errors",
    "title": "Formatted Output",
    "section": "Errors",
    "text": "Errors\nUnder the covers, scribe.format processes table arguments into strings and then relies on string.format to finish the formatting request. This means that scribe.format can raise the same errors as string.format.\nFor example, if you forget to pass a trailing argument:\nputln(\"My name is %s, and I am %d years old.\", \"Tom\")\nThen, the program will crash with an error message that looks like:\n.../scribe.lua:577: bad argument #3 to 'format' (no value)\nstack traceback:\n    [C]: in function 'string.format'\n    .../scribe.lua:577: in function 'scribe.format'\n    .../scribe.lua:642: in function 'scribe.putln'\n    ...\n    [C]: in ?\nIn addition, scribe.format detects invalid placeholders in the template recipe. When that happens, the program does not crash. Instead, it returns a string that should make that programming error clear.\nFor example if you have:\nputln(\"The table is %7t.\", {1,2,3})\nThis will output the error string:\n[FORMAT ERROR]: \"The table: %7t\" -- unknown table specifier: \"7t\"",
    "crumbs": [
      "Home",
      "Formatted Output"
    ]
  },
  {
    "objectID": "pages/formatted-output.html#see-also",
    "href": "pages/formatted-output.html#see-also",
    "title": "Formatted Output",
    "section": "See Also",
    "text": "See Also\nObject-to-String Conversions  Turning the Tables …",
    "crumbs": [
      "Home",
      "Formatted Output"
    ]
  },
  {
    "objectID": "pages/format-options.html",
    "href": "pages/format-options.html",
    "title": "Formatting Options",
    "section": "",
    "text": "If you have loaded the scribe module as:\nlocal scribe = require `scribe'\nYou can call the most general method for converting a Lua object obj to a string:\nlocal obj_string = scribe(obj, opts, overrides)\n\n    \n     \n    \n    \nScribe has pre-canned standard options that cover most use cases. Those methods should usually be your first port of call. You can also use scribe.clone to copy one of those standard options tables and tweak it to get the desired output style for your use case.\n\nThe opts and overrides arguments are both optional.\nIf opts is missing, the method will use the formatting option table scribe.options.default. Out of the box, the default is scribe.options.inline. You can change that if you wish. By default, scribe(obj) returns the string from scribe.inline.\nThe overrides argument is an optional table of tweaks you would like to make to opts. By default, this is nil. See the customisation page for more details.",
    "crumbs": [
      "Home",
      "Format Options"
    ]
  },
  {
    "objectID": "pages/format-options.html#introduction",
    "href": "pages/format-options.html#introduction",
    "title": "Formatting Options",
    "section": "",
    "text": "If you have loaded the scribe module as:\nlocal scribe = require `scribe'\nYou can call the most general method for converting a Lua object obj to a string:\nlocal obj_string = scribe(obj, opts, overrides)\n\n    \n     \n    \n    \nScribe has pre-canned standard options that cover most use cases. Those methods should usually be your first port of call. You can also use scribe.clone to copy one of those standard options tables and tweak it to get the desired output style for your use case.\n\nThe opts and overrides arguments are both optional.\nIf opts is missing, the method will use the formatting option table scribe.options.default. Out of the box, the default is scribe.options.inline. You can change that if you wish. By default, scribe(obj) returns the string from scribe.inline.\nThe overrides argument is an optional table of tweaks you would like to make to opts. By default, this is nil. See the customisation page for more details.",
    "crumbs": [
      "Home",
      "Format Options"
    ]
  },
  {
    "objectID": "pages/format-options.html#formatting-parameters",
    "href": "pages/format-options.html#formatting-parameters",
    "title": "Formatting Options",
    "section": "Formatting Parameters",
    "text": "Formatting Parameters\nIf you do use scribe with the optional second opts argument, it should be a table with the following keys and values:\n\n\n\n\n\n\n\n\n\nThe Key String\nValue Type\nBrief Description of the Value\n\n\n\n\nopts.table_begin\nstring\nThe left delimiter for general tables, e.g., {.\n\n\nopts.table_end\nstring\nThe right delimiter for general tables, e.g., }.\n\n\nopts.array_begin\nstring\nThe left delimiter for array tables, e.g., [.\n\n\nopts.array_end\nstring\nThe right delimiter for array tables, e.g., ].\n\n\nopts.inline_spacer\nstring\nFor example, if this is ' ', then Scribe adds an extra space between inline table/array delimiters and their contents:  You get { ... } instead of {...}.\n\n\nopts.key_begin\nstring\nThe left delimiter for table keys, e.g., ''.\n\n\nopts.key_end\nstring\nThe right delimiter for table keys with assignment, e.g., =.\n\n\nopts.show_indices\nboolean\nControls visibility of indices in arrays.\n\n\nopts.sep\nstring\nThe separator that marks the end of a key-value pair, e.g. ,.\n\n\nopts.indent\nstring\nIndentation for table elements per nesting level, e.g. \"  \".  If indent is set to \"\", the output will be a one-line string.\n\n\nopts.inline_size\nnumber\nWe put simple sub-tables & sub-arrays on one line no matter what indent is set to as long as their size is less than inline_size.\n\n\nopts.comparator\nfunction\nThe comparator function used to sort table keys.  We use a default comparator if comparator isn’t set.  To not use ordered output, explicitly set this to false.\n\n\nopts.path_root\nstring\nA top-level name to anchor path references to shared tables.  Defaults to table.\n\n\nopts.path_sep\nstring\nThe separator to use in paths for shared tables  Defaults to . so paths look like &lt;foo.bar&gt; or perhaps &lt;table&gt;\n\n\nopts.path_begin\nstring\nThe left delimiter for path references. Defaults to &lt;.\n\n\nopts.path_end\nstring\nThe right delimiter for path references. Defaults to &gt;.\n\n\nopts.use_metatable\nboolean\nControls whether we use any custom __tostring() metamethod if present.",
    "crumbs": [
      "Home",
      "Format Options"
    ]
  },
  {
    "objectID": "pages/format-options.html#parameter-definitions",
    "href": "pages/format-options.html#parameter-definitions",
    "title": "Formatting Options",
    "section": "Parameter Definitions",
    "text": "Parameter Definitions\nMost of these format fields do obvious things, like setting a table’s left and right delimiters.\nOthers include:\n\nIf the indent option is the empty string \"\", tables will always be output on one line.\nEven if we use indentation, any simple enough tables or arrays are inlined.  See the Simple Tables section.\nThe output strings can distinguish between general tables and arrays. For example, JSON uses [...] to delimit arrays and {...} for general name-value tables.\nArrays have implicit consecutive integer keys starting at one.  Generally, you don’t need to see those, but you can force them to be output.\nThe path_root and path_sep variables only come into play when a table has shared references. The first time a table is seen, you get a full definition.  You get a reference like &lt;foo.bar&gt; afterwards.\nSee the Ordered Iteration section for more details about the comparator field and how to output tables in a key-sorted order.\nSee the Path References section for more details about the path_* fields.\nSetting use_metatable to false is helpful if you use this module to add a custom __tostring metamethod to a class. It stops infinite recursion.\n\n\n    \n     \n    \n    \nThe values for all of the keys are used. However, you can just set the ones you want to customise. The scribe method will fill the rest with reasonable defaults.\n\nScribe has pre-canned standard options that cover most use cases. You can always copy and tweak the fields in one of those to get the desired output style for tables.",
    "crumbs": [
      "Home",
      "Format Options"
    ]
  },
  {
    "objectID": "pages/format-options.html#simple-tables",
    "href": "pages/format-options.html#simple-tables",
    "title": "Formatting Options",
    "section": "Simple Tables",
    "text": "Simple Tables\nA table or array is simple if it has no nested sub-tables or sub-arrays.\nThere is also an optional limit on the number of elements that can be present for a table to be considered “simple”.\nThe inline_size field in the formatting options table controls this. If a table has no sub-tables, and if the number of elements in is less than inline_size, then the table is output on one line.\nThe pretty formatting parameters sets inline_size to math.huge, so all simple tables are output on one line. The classic formatting parameters sets inline_size to 0, so no inlining is ever done.\nMore sophisticated limits might incorporate the number of characters it takes to describe a simple table.",
    "crumbs": [
      "Home",
      "Format Options"
    ]
  },
  {
    "objectID": "pages/format-options.html#ordered-iteration",
    "href": "pages/format-options.html#ordered-iteration",
    "title": "Formatting Options",
    "section": "Ordered Iteration",
    "text": "Ordered Iteration\nIn Lua, the storage order for the elements in a general key-value table is undefined. For example, if you have a little snippet of code like:\nlocal tbl = {\n    first = 'Minnie',\n    last = 'Mouse',\n    email = 'minnie@disney.com'\n}\nfor k, v in pairs(tbl) do\n    print(k, \"=\", v)\nend\nRun it several times, and you will see that the output order is not fixed!\nOn the first run, you might get:\nemail   =   minnie@disney.com\nfirst   =   Minnie\nlast    =   Mouse\nOn the next:\nlast    =   Mouse\nemail   =   minnie@disney.com\nfirst   =   Minnie\nAnd so on.\nThis is not the case for Lua arrays stored in the natural increasing index order.\nSeeing different outputs every time you print a table can be disconcerting, so scribe can fix the element output order for general key-value tables. This is controlled by the comparator field in the formatting options table.\nIf that parameter is explicitly set to false, scribe will iterate through tables using the standard pairs method. The output order of the elements is then undefined and will vary from run to run.\nIf the comparator field is left empty, then Scribe will iterate through tables in a predefined manner. The default sorting function orders the keys alphanumerically by type first and then value. The number type comes before the string type, so typically, the array part of any table appears first.\nYou can also set the comparator value to a custom function cmp(k1, k2) that takes two keys k1 and k2 and returns true if you want k1 to come before k2 when you print the table.\nAll the standard option sets set the comparator field to the default key comparison method. This means that for our Disney example, print(scribe(tbl)) will always output:\n{ email = \"minnie@disney.com\", first = \"Minnie\", last = \"Mouse\" }\nYou can see that the table appears with its keys sorted in increasing alphabetical order.\nYou can change the order by passing a custom comparator function in the overrides argument:\nprint(scribe(tbl, { comparator = function(a,b) return a &gt; b end }))\nThis will output the table with the keys sorted in decreasing alphabetical order.\n{ last = \"Mouse\", first = \"Minnie\", email = \"minnie@disney.com\" }\nThis works fine on a one-off basis. See the customisation page to set that as a new default.",
    "crumbs": [
      "Home",
      "Format Options"
    ]
  },
  {
    "objectID": "pages/format-options.html#path-references",
    "href": "pages/format-options.html#path-references",
    "title": "Formatting Options",
    "section": "Path References",
    "text": "Path References\nIf a table has shared references, Scribe will output the full definition of the table at the shallowest depth possible. After that, it will use a path string to reference the shared table.\nIf the path_root field is table, then a reference to the table itself will be the path &lt;table&gt;.\nMore commonly, you will get paths like &lt;foo.bar&gt;, which refers to the value found by following the key chain foo.bar from the root table, If the root table is tbl, then that path reference is to the value tbl[foo][bar].",
    "crumbs": [
      "Home",
      "Format Options"
    ]
  },
  {
    "objectID": "pages/format-options.html#the-default-format",
    "href": "pages/format-options.html#the-default-format",
    "title": "Formatting Options",
    "section": "The Default Format",
    "text": "The Default Format\nA default set of formatting options is used when you call scribe(tbl) without any second argument. Out of the box, this is scribe.options.inline, which means scribe(tbl) returns a one-line string representation of tbl.\nYou can change that to, say, a multiline string for all tables by:\n scribe.options.default = scribe.options.pretty\nFrom then on, scribe(tbl) will be the same as scribe.pretty.",
    "crumbs": [
      "Home",
      "Format Options"
    ]
  },
  {
    "objectID": "pages/format-options.html#see-also",
    "href": "pages/format-options.html#see-also",
    "title": "Formatting Options",
    "section": "See Also",
    "text": "See Also\nStandard Options  Custom Options  Object-to-String Conversions  Formatted Output  Turning the Tables …",
    "crumbs": [
      "Home",
      "Format Options"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Scribe",
    "section": "",
    "text": "Scribe converts Lua objects to readable strings.\nScribe also has formatted output methods that make it easy to print tables. It adds formatting specifiers for tables to Lua’s standard string.format facility. Amongst others, Scribe uses %t to output tables on a single line and %T to pretty-print them on multiple lines.\nFor example:\nlocal putln = require('scribe').putln\nlocal arr = {1,2,3}\nputln(\"Array: %t\", tbl)\nThis prints Array: [ 1, 2, 3 ] followed by a newline to stdout.\nScribe gracefully handles complex tables, including ones with shared and cyclical references. The strings returned for those tables show the underlying structure in a manner that is as readable as possible.\nIf you have:\nlocal classes = {p1 = {subject = 'History', room = 401}, p2 = {subject = 'Spanish', room = 321}}\nclasses.p1.next = classes.p2\nclasses.p2.prev = classes.p1\nThen putln(\"Classes: %T\", classes) prints:\nClasses: {\n    p1 = { next = &lt;p2&gt;, room = 401, subject = \"History\" },\n    p2 = { prev = &lt;p1&gt;, room = 321, subject = \"Spanish\" }\n}\nYou can customise scribe by passing a table of formatting options. You can set many options, allowing for many table styles.\nThat flexibility is great, but the number of available options can be daunting. Therefore, scribe has pre-defined standard options that work out of the box for most applications. Those include option sets and methods for turning tables in JSON-style strings.\nIt is also easy to tweak one of those standards to achieve a custom look for table strings.",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "Scribe",
    "section": "",
    "text": "Scribe converts Lua objects to readable strings.\nScribe also has formatted output methods that make it easy to print tables. It adds formatting specifiers for tables to Lua’s standard string.format facility. Amongst others, Scribe uses %t to output tables on a single line and %T to pretty-print them on multiple lines.\nFor example:\nlocal putln = require('scribe').putln\nlocal arr = {1,2,3}\nputln(\"Array: %t\", tbl)\nThis prints Array: [ 1, 2, 3 ] followed by a newline to stdout.\nScribe gracefully handles complex tables, including ones with shared and cyclical references. The strings returned for those tables show the underlying structure in a manner that is as readable as possible.\nIf you have:\nlocal classes = {p1 = {subject = 'History', room = 401}, p2 = {subject = 'Spanish', room = 321}}\nclasses.p1.next = classes.p2\nclasses.p2.prev = classes.p1\nThen putln(\"Classes: %T\", classes) prints:\nClasses: {\n    p1 = { next = &lt;p2&gt;, room = 401, subject = \"History\" },\n    p2 = { prev = &lt;p1&gt;, room = 321, subject = \"Spanish\" }\n}\nYou can customise scribe by passing a table of formatting options. You can set many options, allowing for many table styles.\nThat flexibility is great, but the number of available options can be daunting. Therefore, scribe has pre-defined standard options that work out of the box for most applications. Those include option sets and methods for turning tables in JSON-style strings.\nIt is also easy to tweak one of those standards to achieve a custom look for table strings.",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "Scribe",
    "section": "Installation",
    "text": "Installation\nThe module has no dependencies.  Copy the single scribe.lua file into a project and start to use it.\nReleased versions will also be uploaded to the luarocks repository, so you should be able to install them using:\nluarocks install scribe",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "index.html#conversion-methods",
    "href": "index.html#conversion-methods",
    "title": "Scribe",
    "section": "Conversion Methods",
    "text": "Conversion Methods\nIf you have imported the module as\nlocal scribe = require 'scribe'\nThen, the following methods convert arbitrary Lua objects to readable strings.\nClick on a function name to get calling details, examples, etc.\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\nscribe.scribe\nThe most general string method.  This method can use custom formatting options.\n\n\nscribe.inline\nSingle line output where arrays are delimited by [ ... ].  General name-value tables are delimited by { ... }.\n\n\nscribe.pretty\nMultiline format with the same delimiters as inline.  Simple, non-nested tables & arrays are on a single line.\n\n\nscribe.classic\nMultiline format where all tables are delimited by { ... }.  No tables are inlined.\n\n\nscribe.alt\nAn alternate, multiline format without table delimiters.  This uses indentation to show table structure.\n\n\nscribe.json\nConverts tables to a multiline JSON string format.\n\n\nscribe.inline_json\nConverts tables to a compact one-line JSON string format.\n\n\nscribe.debug\nOutput tables as an abstract syntax tree.  Useful if you design a scribe option table.\n\n\nscribe.clone\nReturns a shallow copy of a table.  Can be used to copy a standard option table for customisation.\n\n\n\n\n\n    \n     \n    \n    \nscribe(...) is a succinct synonym for scribe.scribe(...).  Out of the box, the one-argument version scribe(object) is the same as scribe.inline(object). You can change that default to something else.",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "index.html#formatting-options",
    "href": "index.html#formatting-options",
    "title": "Scribe",
    "section": "Formatting Options",
    "text": "Formatting Options\nscribe.inline, etc., call scribe(obj, options) with a specific set of pre-canned options. Those customise the output string to get a particular look.\nYou can also supply your formatting options or add tweaks to one of the standard sets.\nSee scribe.options for all the details.",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "index.html#formatted-output",
    "href": "index.html#formatted-output",
    "title": "Scribe",
    "section": "Formatted Output",
    "text": "Formatted Output\nBeyond table-to-string conversions, Scribe provides functions to create and print formatted strings.\nThose functions build on Lua’s string.format capabilities by adding extra format specifiers for Lua tables.\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\nscribe.format\nBuilds a formatted string from a template string with placeholders.  The trailing arguments should supply values for those placeholders.\n\n\nscribe.put\nWrites a formatted string to stdout.\n\n\nscribe.putln\nWrites a formatted string followed by a newline to stdout.\n\n\nscribe.eput\nWrites a formatted string to stderr.\n\n\nscribe.eput\nWrites a formatted string followed by a newline to stderr.\n\n\nscribe.fput\nWrites a formatted string to the file f.\n\n\nscribe.fput\nWrites a formatted string followed by a newline to the file f.\n\n\n\n\nThe various *put* methods use scribe.format to create a string from a recipe that can include instructions to convert tables to various styled strings and then output the result.",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "index.html#format-specifiers",
    "href": "index.html#format-specifiers",
    "title": "Scribe",
    "section": "Format Specifiers",
    "text": "Format Specifiers\nAs well as all the usual Lua format specifiers like %s for strings, Scribe recognises the following extra ones for tables:\n\n\n\n\n\n\n\n\nSpecifier\nBrief Description of the Corresponding Table\n\n\n\n\n%t\nA one-line string where arrays are delimited by [ ... ] and other tables by { ... }\n\n\n%T\nA pretty multiline string where simple arrays and tables remain on one line.  Arrays are delimited by [ ... ] and other tables by { ... }\n\n\n%2T\nA “classic” multiline string using curly brace delimiters and putting each element on its line.\n\n\n%3T\nA multiline string with no table delimiters.  Structure is shown using indentation alone.\n\n\n%9T\nA debug string showing the abstract structure of the table. Mainly for internal use.\n\n\n%J\nA multiline JSON string.\n\n\n%j\nA compact one-line JSON string.\n\n\n\n\n\n    \n     \n    \n    \nThe lower-case format table specifiers %t and %j always produce one-line strings. The upper-case specifiers generally produce multiline outputs.\n\nExample:\nlocal putln = require('scribe').putln\nlocal pupils = { { name = 'Mary', age = 12 }, { name = 'Joe', age = 11 } }\nputln(\"Our pupils: %T\", pupils)\nOutput:\n1Our pupils: [\n2    { age = 12, name = \"Mary\" },\n    { age = 11, name = \"Joe\" }\n]\n\n1\n\npupils is an array of two tables so the outer delimiters are square brackets.\n\n2\n\nNote that in this “pretty” %T format we print simple sub-tables on one line. See scribe.pretty.\n\n\nThe same example can be output as a valid JSON array by calling putln(\"%J\", pupils), which yields:\nJSON Output:\n[\n1    {\n        \"age\": 12,\n        \"name\": \"Mary\"\n    },\n    {\n        \"age\": 11,\n        \"name\": \"Joe\"\n    }\n]\n\n1\n\nThe classic JSON multiline format puts all elements on separate lines.",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "index.html#see-also",
    "href": "index.html#see-also",
    "title": "Scribe",
    "section": "See Also",
    "text": "See Also\nObject-to-String Conversions  Formatting Options  Standard Options  Custom Options  Formatted Output  Turning the Tables …",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "pages/index.html",
    "href": "pages/index.html",
    "title": "Scribe",
    "section": "",
    "text": "Scribe converts Lua objects to readable strings.\nScribe also has formatted output methods that make it easy to print tables. It adds formatting specifiers for tables to Lua’s standard string.format facility. Amongst others, Scribe uses %t to output tables on a single line and %T to pretty-print them on multiple lines.\nFor example:\nlocal putln = require('scribe').putln\nlocal arr = {1,2,3}\nputln(\"Array: %t\", tbl)\nThis prints Array: [ 1, 2, 3 ] followed by a newline to stdout.\nScribe gracefully handles complex tables, including ones with shared and cyclical references. The strings returned for those tables show the underlying structure in a manner that is as readable as possible.\nIf you have:\nlocal classes = {p1 = {subject = 'History', room = 401}, p2 = {subject = 'Spanish', room = 321}}\nclasses.p1.next = classes.p2\nclasses.p2.prev = classes.p1\nThen putln(\"Classes: %T\", classes) prints:\nClasses: {\n    p1 = { next = &lt;p2&gt;, room = 401, subject = \"History\" },\n    p2 = { prev = &lt;p1&gt;, room = 321, subject = \"Spanish\" }\n}\nYou can customise scribe by passing a table of formatting options. You can set many options, allowing for many table styles.\nThat flexibility is great, but the number of available options can be daunting. Therefore, scribe has pre-defined standard options that work out of the box for most applications. Those include option sets and methods for turning tables in JSON-style strings.\nIt is also easy to tweak one of those standards to achieve a custom look for table strings."
  },
  {
    "objectID": "pages/index.html#introduction",
    "href": "pages/index.html#introduction",
    "title": "Scribe",
    "section": "",
    "text": "Scribe converts Lua objects to readable strings.\nScribe also has formatted output methods that make it easy to print tables. It adds formatting specifiers for tables to Lua’s standard string.format facility. Amongst others, Scribe uses %t to output tables on a single line and %T to pretty-print them on multiple lines.\nFor example:\nlocal putln = require('scribe').putln\nlocal arr = {1,2,3}\nputln(\"Array: %t\", tbl)\nThis prints Array: [ 1, 2, 3 ] followed by a newline to stdout.\nScribe gracefully handles complex tables, including ones with shared and cyclical references. The strings returned for those tables show the underlying structure in a manner that is as readable as possible.\nIf you have:\nlocal classes = {p1 = {subject = 'History', room = 401}, p2 = {subject = 'Spanish', room = 321}}\nclasses.p1.next = classes.p2\nclasses.p2.prev = classes.p1\nThen putln(\"Classes: %T\", classes) prints:\nClasses: {\n    p1 = { next = &lt;p2&gt;, room = 401, subject = \"History\" },\n    p2 = { prev = &lt;p1&gt;, room = 321, subject = \"Spanish\" }\n}\nYou can customise scribe by passing a table of formatting options. You can set many options, allowing for many table styles.\nThat flexibility is great, but the number of available options can be daunting. Therefore, scribe has pre-defined standard options that work out of the box for most applications. Those include option sets and methods for turning tables in JSON-style strings.\nIt is also easy to tweak one of those standards to achieve a custom look for table strings."
  },
  {
    "objectID": "pages/index.html#installation",
    "href": "pages/index.html#installation",
    "title": "Scribe",
    "section": "Installation",
    "text": "Installation\nThe module has no dependencies.  Copy the single scribe.lua file into a project and start to use it.\nReleased versions will also be uploaded to the luarocks repository, so you should be able to install them using:\nluarocks install scribe"
  },
  {
    "objectID": "pages/index.html#conversion-methods",
    "href": "pages/index.html#conversion-methods",
    "title": "Scribe",
    "section": "Conversion Methods",
    "text": "Conversion Methods\nIf you have imported the module as\nlocal scribe = require 'scribe'\nThen, the following methods convert arbitrary Lua objects to readable strings.\nClick on a function name to get calling details, examples, etc.\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\nscribe.scribe\nThe most general string method.  This method can use custom formatting options.\n\n\nscribe.inline\nSingle line output where arrays are delimited by [ ... ].  General name-value tables are delimited by { ... }.\n\n\nscribe.pretty\nMultiline format with the same delimiters as inline.  Simple, non-nested tables & arrays are on a single line.\n\n\nscribe.classic\nMultiline format where all tables are delimited by { ... }.  No tables are inlined.\n\n\nscribe.alt\nAn alternate, multiline format without table delimiters.  This uses indentation to show table structure.\n\n\nscribe.json\nConverts tables to a multiline JSON string format.\n\n\nscribe.inline_json\nConverts tables to a compact one-line JSON string format.\n\n\nscribe.debug\nOutput tables as an abstract syntax tree.  Useful if you design a scribe option table.\n\n\nscribe.clone\nReturns a shallow copy of a table.  Can be used to copy a standard option table for customisation.\n\n\n\n\n\n    \n     \n    \n    \nscribe(...) is a succinct synonym for scribe.scribe(...).  Out of the box, the one-argument version scribe(object) is the same as scribe.inline(object). You can change that default to something else."
  },
  {
    "objectID": "pages/index.html#formatting-options",
    "href": "pages/index.html#formatting-options",
    "title": "Scribe",
    "section": "Formatting Options",
    "text": "Formatting Options\nscribe.inline, etc., call scribe(obj, options) with a specific set of pre-canned options. Those customise the output string to get a particular look.\nYou can also supply your formatting options or add tweaks to one of the standard sets.\nSee scribe.options for all the details."
  },
  {
    "objectID": "pages/index.html#formatted-output",
    "href": "pages/index.html#formatted-output",
    "title": "Scribe",
    "section": "Formatted Output",
    "text": "Formatted Output\nBeyond table-to-string conversions, Scribe provides functions to create and print formatted strings.\nThose functions build on Lua’s string.format capabilities by adding extra format specifiers for Lua tables.\n\n\n\n\n\n\n\n\nMethod\nBrief Description\n\n\n\n\nscribe.format\nBuilds a formatted string from a template string with placeholders.  The trailing arguments should supply values for those placeholders.\n\n\nscribe.put\nWrites a formatted string to stdout.\n\n\nscribe.putln\nWrites a formatted string followed by a newline to stdout.\n\n\nscribe.eput\nWrites a formatted string to stderr.\n\n\nscribe.eput\nWrites a formatted string followed by a newline to stderr.\n\n\nscribe.fput\nWrites a formatted string to the file f.\n\n\nscribe.fput\nWrites a formatted string followed by a newline to the file f.\n\n\n\n\nThe various *put* methods use scribe.format to create a string from a recipe that can include instructions to convert tables to various styled strings and then output the result."
  },
  {
    "objectID": "pages/index.html#format-specifiers",
    "href": "pages/index.html#format-specifiers",
    "title": "Scribe",
    "section": "Format Specifiers",
    "text": "Format Specifiers\nAs well as all the usual Lua format specifiers like %s for strings, Scribe recognises the following extra ones for tables:\n\n\n\n\n\n\n\n\nSpecifier\nBrief Description of the Corresponding Table\n\n\n\n\n%t\nA one-line string where arrays are delimited by [ ... ] and other tables by { ... }\n\n\n%T\nA pretty multiline string where simple arrays and tables remain on one line.  Arrays are delimited by [ ... ] and other tables by { ... }\n\n\n%2T\nA “classic” multiline string using curly brace delimiters and putting each element on its line.\n\n\n%3T\nA multiline string with no table delimiters.  Structure is shown using indentation alone.\n\n\n%9T\nA debug string showing the abstract structure of the table. Mainly for internal use.\n\n\n%J\nA multiline JSON string.\n\n\n%j\nA compact one-line JSON string.\n\n\n\n\n\n    \n     \n    \n    \nThe lower-case format table specifiers %t and %j always produce one-line strings. The upper-case specifiers generally produce multiline outputs.\n\nExample:\nlocal putln = require('scribe').putln\nlocal pupils = { { name = 'Mary', age = 12 }, { name = 'Joe', age = 11 } }\nputln(\"Our pupils: %T\", pupils)\nOutput:\n1Our pupils: [\n2    { age = 12, name = \"Mary\" },\n    { age = 11, name = \"Joe\" }\n]\n\n1\n\npupils is an array of two tables so the outer delimiters are square brackets.\n\n2\n\nNote that in this “pretty” %T format we print simple sub-tables on one line. See scribe.pretty.\n\n\nThe same example can be output as a valid JSON array by calling putln(\"%J\", pupils), which yields:\nJSON Output:\n[\n1    {\n        \"age\": 12,\n        \"name\": \"Mary\"\n    },\n    {\n        \"age\": 11,\n        \"name\": \"Joe\"\n    }\n]\n\n1\n\nThe classic JSON multiline format puts all elements on separate lines."
  },
  {
    "objectID": "pages/index.html#see-also",
    "href": "pages/index.html#see-also",
    "title": "Scribe",
    "section": "See Also",
    "text": "See Also\nObject-to-String Conversions  Formatting Options  Standard Options  Custom Options  Formatted Output  Turning the Tables …"
  },
  {
    "objectID": "pages/tutorial/index.html",
    "href": "pages/tutorial/index.html",
    "title": "Tutorial: Turning the Tables …",
    "section": "",
    "text": "Lua’s only rich native type is the table.\nThe table is the only game in town, so you will use it to implement every non-trivial data structure you need in any Lua project.\nIn this article, we will gradually build scribe, a Lua module that converts tables (and other Lua types) to readable strings.\nConverting arbitrary Lua tables into descriptive strings is more complex than it initially appears. We’ll examine the issues that arise and how scribe addresses some of the pitfalls.\nWe will start with a trivial implementation in a dozen lines of Lua. Over time, we will evolve that code into a production-ready Lua module that handles the most complex tables with cycles and shared references. We will also see how to support multiple output formats in a single code block.\nThis blow-by-blow description and the liberally documented final product, scribe.lua, should be a helpful tutorial, at least for those new to Lua, especially those with experience in other languages.\n\n    \n     \n    \n    \nThis is not an introduction to Lua. Think of it as more Lua 201 than Lua 101.\n\nThis article is long, but we have tried to make it worthwhile.  And, of course, we hope you find scribe itself as helpful as we do!",
    "crumbs": [
      "Home",
      "Turning the Tables ..."
    ]
  },
  {
    "objectID": "pages/tutorial/index.html#introduction",
    "href": "pages/tutorial/index.html#introduction",
    "title": "Tutorial: Turning the Tables …",
    "section": "",
    "text": "Lua’s only rich native type is the table.\nThe table is the only game in town, so you will use it to implement every non-trivial data structure you need in any Lua project.\nIn this article, we will gradually build scribe, a Lua module that converts tables (and other Lua types) to readable strings.\nConverting arbitrary Lua tables into descriptive strings is more complex than it initially appears. We’ll examine the issues that arise and how scribe addresses some of the pitfalls.\nWe will start with a trivial implementation in a dozen lines of Lua. Over time, we will evolve that code into a production-ready Lua module that handles the most complex tables with cycles and shared references. We will also see how to support multiple output formats in a single code block.\nThis blow-by-blow description and the liberally documented final product, scribe.lua, should be a helpful tutorial, at least for those new to Lua, especially those with experience in other languages.\n\n    \n     \n    \n    \nThis is not an introduction to Lua. Think of it as more Lua 201 than Lua 101.\n\nThis article is long, but we have tried to make it worthwhile.  And, of course, we hope you find scribe itself as helpful as we do!",
    "crumbs": [
      "Home",
      "Turning the Tables ..."
    ]
  },
  {
    "objectID": "pages/tutorial/index.html#lua-types",
    "href": "pages/tutorial/index.html#lua-types",
    "title": "Tutorial: Turning the Tables …",
    "section": "Lua Types",
    "text": "Lua Types\nLike every other programming language ever invented, the classic first Lua script is:\nstr = \"Hello World\"\nprint(str)\nAnd, hey presto, it works! On your terminal, the output is:\nHello World\nThat handy print function works as you’d expect for many Lua types.\n\n    \n     \n    \n    \nLua always aims for the minimal and has only eight types in total.  Compare that to Rust, which has twelve types just for integers!\n\nBy the way, Lua’s tostring function is a companion to print and converts any Lua type to a string.\n\nSimple Types\nThe four most straightforward Lua types are number, boolean, string and nil:\n1str = \"Cinderella\"\n2answer = 42\n3pi = 3.14\n4flag = false\n5oops = nil\nprint(str, answer, pi, flag, oops)\n\n1\n\nA string.\n\n2\n\nA number that is an integer.\n\n3\n\nThis number is a float, but Lua uses one type for integers and floats.\n\n4\n\nA boolean.\n\n5\n\nA special nil type indicates not-founds, fails, etc.\n\n\nIn each case, you get very reasonable results on your screen:\nCinderella  42 3.14 false nil\nWe can use print to dump recognisable values from number, boolean, string and even nil.\nThe simplest form of debugging is to sprinkle print statements throughout your code liberally, so the more types print works on, the better. Sure, it’s not elegant, but every programmer uses print statements when things go awry. Even more so in a non-compiled, dynamic language like Lua, where adding a print statement and rerunning happens as fast as you can type.\nLua has four additional types beyond number, string, boolean, and nil. These are function, userdata, thread and table.\n\n\nLua Functions\nLua methods you write or import all have the type function.  Let’s look at a simple function example:\nfunction answer() return 42 end\n1print(answer())\n2print(answer)\n\n1\n\nThis prints whatever is returned from our answer function.\n\n2\n\nThis prints what Lua thinks of as the function itself.\n\n\nOutput:\n42\n1function: 0x600003e6cca0\n\n1\n\nThe part after the colon will vary from run to run.\n\n\nThe string \"function\" is descriptive enough, but the string 0x... that follows the colon is opaque. It is the address in memory where Lua stores its form of the function in question. That is consistent for a single run, so if you print the function twice:\nfunction answer() return 42 end\nprint(answer)\nprint(answer)\nThe code outputs the exact string twice, e.g.\nfunction: 0x6000032a8ca0\nfunction: 0x6000032a8ca0\nHowever, the next time you run the program, you’ll get something else, such as\nfunction: 0x600002650ca0\nfunction: 0x600002650ca0\nWe don’t usually write things like print(answer) in our code except by accident! When we do, it’s likely a bug. We probably meant to write print(answer()) with those parentheses () that tells Lua to please execute the answer function and capture the result, So, while the output from print(answer) is opaque, it’s generally followed by an “oops, I forgot some parentheses!”\n\n\nTwo Non-Native Types\nOne of Lua’s great strengths is its ability to interface with things written in other languages. Lua’s two non-native types, userdata and thread, are associated with non-native items.\nWhen you try to print something implemented in another language, it is hardly surprising that Lua can only say, “I see that as a piece of user data located at this address in memory.”\nYou can’t expect much more; if you need something more descriptive, you’d expect to perform that action in another language.\n\n\nArray Tables\nFinally, we come to the all-important table type, starting with Lua arrays, a subset of this type.\nThe table type is Lua’s only “complex” native data type and is amazingly versatile. Once you use Lua for anything beyond trivial scripts, you will inevitably build and interpret many tables.\nTables can contain all Lua types, including Lua functions and other tables, which can refer to each other in cycles, etc.\nBut let’s start with a simple array example:\ngents = {'Tom', 'Dick', 'Harry'}\nprint(gents)\nThe corresponding output will be something like:\ntable: 0x600001d32980\nThis output is similar in spirit to what we got by calling print on that Lua function shown above. Lua recognises the gents object as a table at some memory address, and that’s all it reveals.\nTo emphasise the point, we note that the Lua assignment operator for tables creates another variable that points to the same table:\ngents = {'Tom', 'Dick', 'Harry'}\naka = gents\nprint(gents)\nprint(aka)\nThis outputs:\n1table: 0x600002e96940\n2table: 0x600002e96940\n\n1\n\nThe variables gents and aka are really pointers to the same memory address.\n\n2\n\nThe specific memory location will vary from run to run,\n\n\nOf course, this output is not helpful and isn’t what you’d naively expect!\nYou search for “How do I print a Lua array?” and find an answer like:\nprint(table.concat(gents, \", \"))\nAnd sure enough, out pops the string “Tom, Dick, Harry”.\nAt this point, you may feel aggrieved!\nWhy didn’t print(gents) return something like \"Tom\", \"Dick\", \"Harry\" in the first place? What is that table.concat(...) call? Everybody would prefer the second output over being told that Lua recognises gents as a table that resides at some address in memory. There must be a better way!\n\n\nKey-Value Tables\nThings get even more screwy when you try to print a more general Lua table that isn’t an array:\n1mouse = {\n    first = 'Minnie',\n    last = 'Mouse'\n}\n\n1\n\nThis is a Lua table with two name-value pairs.\n\n\nLua adheres to Mies Van der Rohe’s “less is more” mantra. It likes to keep things simple!\nFor example, we saw earlier that the Lua number type encompasses all classes of integers and all classes of floating-point numbers. Other “system-level” computer languages distinguish between them, as every piece of computer hardware has different paths for the types at the chip level. Programmers of those languages must understand and care about the differences between integers and floats. That distinction makes sense if you want to squeeze the maximum performance from every CPU nanosecond.\nLua has different goals. It is still efficient, but it is willing to spare a few compute cycles to limit type complexity for the programmer. If you code in Lua, you can only use generic “numbers” and trust that Lua handles them efficiently, whatever the form of those numbers of interest may be.\nThe Lua table type is similar, encompassing simple arrays, like the gents example, and more general hash map tables with explicit keys and values, like the mouse example. This combination seems odd if you have done any programming before encountering Lua.\nThe other “real” computer languages you learnt all distinguish between arrays and dictionaries. In those languages, arrays are part of the core language. A long, early manual chapter will expound on their use. The description for the name-value dictionary-type container will be in the back of the book in the section dedicated to the language’s “standard” library. This division reflects that the hardware paths for the two container types are generally very different. Arrays are considered more fundamental than dictionaries of name-value pairs.\nLua, in effect, says:\n\nTrust me, build that table however makes the most sense to you, and let me worry about efficiency.\n\nOverall, this works remarkably well. Lua internally splits tables into an array part that zips along the high-speed lane of the hardware highway and a dictionary part that is necessarily over on a lower-speed lane. Again, the trade-off is between programming simplicity with a “trust me, I’ll get you almost the same speed” clause and the maximum performance per nanosecond.\nGiven our lack of success at getting something useful out of print for an array, we aren’t going to be surprised to see similar nonsense from print(mouse):\ntable: 0x6000027d9b00\nLua tells you that mouse is a table residing at a specific memory location.  True, but not very helpful!\nIf we try our earlier trick\nprint(table.concat(mouse, \", \"))\nLua outputs a blank line. Well, you just learnt something—apparently, table.concat only works on Lua array-like tables.\n\n    \n     \n    \n    \nA Lua array has implicit keys with successive integers starting at 1. General Lua hash tables have explicit keys, such as the strings first and last in the mouse example. The keys can be any Lua object, not just strings.\n\nOf course, we can unpack our table and write:\nprint(name.first, name.last)\nThen we get “Minnie Mouse”.\nAnother quick search provides an answer for tables with an arbitrary number of key-value pairs:\nfor k, v in pairs(mouse) do\n    print(k,v)\nend\nWhen I ran it the first time, this output:\nlast    Mouse\nfirst   Minnie\nThe output is a valid representation of the data but not in a natural order. Running the script a few more times may eventually give a better order:\nfirst   Minnie\nlast    Mouse\n\n    \n     \n    \n    \nLua stores key-value tables in an undefined order, which can vary from run to run. The pairs function iterates through the key-value pairs in storage order, so it’s not constant. Arrays, on the other hand, are always stored in the natural increasing index order.",
    "crumbs": [
      "Home",
      "Turning the Tables ..."
    ]
  },
  {
    "objectID": "pages/tutorial/index.html#first-shot-at-tables",
    "href": "pages/tutorial/index.html#first-shot-at-tables",
    "title": "Tutorial: Turning the Tables …",
    "section": "First Shot at Tables",
    "text": "First Shot at Tables\nAt this point in your Lua journey, you probably search for “How do I convert a Lua table to a string?”. You will find a lot of suggestions, some quite good and some not so good.\nBut suppose you wish to build your very own solution based on the discovery that you can use the pairs function to iterate through a table.\nWell, you know that recursion is the touch of the hand of God and that Spidey sense is telling you this is the place to use it!\nWith a little spare time on your hands, you come with code along the lines of:\n1function table_string(tbl)\n2    local indent = '    '\n3    local retval = '{\\n'\n    for k, v in pairs(tbl) do\n4        retval = retval .. indent\n5        retval = retval .. tostring(k) .. ' = '\n        if type(v) ~= 'table' then\n6            retval = retval .. tostring(v)\n        else\n7            retval = retval .. table_string(v)\n        end\n8        retval = retval .. ',\\n'\n    end\n9    retval = retval ..  '\\n}'\n    return retval\nend\n\n1\n\nA descriptive function name. However, we should check that tbl is a Lua table!\n\n2\n\nWe hard code the indent to four spaces.  This is a parameter the user will want to set.\n\n3\n\nStart the return string with a {and a newline character.  The user might want to set the table delimiters to something other than braces.\n\n4\n\nIndent every key-value pair inside the table.\n\n5\n\nAdd the key k as a string and an assignment =.  Another potentially user-settable parameter.\n\n6\n\nThe value v isn’t a table. We can use tostring and add it to the return value.\n\n7\n\nA sub-table! “Look, Ma, that’s recursion. I’m a real programmer!””\n\n8\n\nEnd the table element with a separator , followed by a newline character.\n\n9\n\nFinally, close the string with a newline character and a matching table end-delimiter }.\n\n\n\n    \n     \n    \n    \nWhile we have begun handling nested sub-tables using recursion, this version will not get the indentation right. We’ll come back to that problem shortly.\n\nYou try it out on our little mouse by calling print(table_string(mouse)), which returns:\n{\n    first = Minnie,\n1    last = Mouse,\n\n}\n\n1\n\nThat’s an annoying extra comma and newline character after the final table element.\n\n\nOverall, it’s not bad! There is that extra comma and new line that looks a bit off, and of course, if you run that print(table_string(mouse)) a few times, you will see that the print order of the elements changes:\n{\n    last = Mouse,\n1    first = Minnie,\n\n}\n\n1\n\nThe element order changed, but the extra comma and newline character remains firmly in place.\n\n\n\nMaking indent a Parameter\nBefore we tackle the extra comma and newline character, let’s make indent a parameter. This is easy to do by adding a second optional argument to the function:\n1function table_string(tbl, indent)\n2    indent = indent or '    '\n    ...\n\n1\n\nWe add a second argument to the function, which should be a string.\n\n2\n\nIf the user doesn’t provide a value for indent, we default to four spaces.\n\n\nOnly multiline formats will ever use indentation. The output should be a single line if the function is called with an indent as the empty string. We can use this check to trigger inline versus multiline output:\nfunction table_string(tbl, indent)\n    indent  = indent or '    '\n\n1    local nl     = indent == '' and '' or '\\n'\n2    local retval = '{' .. nl\n    for k, v in pairs(tbl) do\n        retval = retval .. indent\n        retval = retval .. tostring(k) .. ' = '\n        if type(v) ~= 'table' then\n            retval = retval .. tostring(v)\n        else\n3            retval = retval .. table_string(v, indent)\n        end\n4        retval = retval .. ',' .. nl\n    end\n5    retval = retval .. nl .. '}'\n    return retval\nend\n\n1\n\nWe parametrise the “newline character” nl and set it to the empty string for inline outputs.\n\n2\n\nInstead of hard-coding the newline character, we add nl to the opening brace\n\n3\n\nWe pass indent to the recursive call.\n\n4\n\nWe add nl to the separator ,.\n\n5\n\nFinally, we add nl to the closing brace.\n\n\n\n    \n     \n    \n    \nWhenever you change the calling signature of a recursive function, you must update the recursive call to match. From experience, this is a common source of bugs.\n\nNow, if you call print(table_string(mouse, '')), you will get:\n{first = Minnie,last = Mouse,}\nThat’s a single line with no newlines or indentation, though there is an extra trailing comma we need to eliminate.",
    "crumbs": [
      "Home",
      "Turning the Tables ..."
    ]
  },
  {
    "objectID": "pages/tutorial/index.html#anatomy-of-a-table",
    "href": "pages/tutorial/index.html#anatomy-of-a-table",
    "title": "Tutorial: Turning the Tables …",
    "section": "Anatomy of a Table",
    "text": "Anatomy of a Table\nAlthough our current output string is flawed, nonetheless, it highlights the general structure for any table:\ntable-begin-delimiter\n    content\ntable-end-delimiter\nIn our first attempt, the table_begin and table_end delimiters are the opening and closing braces surrounding the table content. The table delimiters should be user-configurable.\nThe table content is a sequence of zero or more elements:\ntable-begin-delimiter\n    element,\n    element,\n    ...\ntable-end-delimiter\nEach element includes a key, possibly an assignment operator, and a value. Array “keys” are the array indices and are often not shown as they are implicit in the ordering of the values.\nIn some formats like JSON, the keys must be enclosed in double-quotes. We can accommodate that requirement by introducing key delimiters, key_begin and key_end. The assignment operator can always be incorporated as part of key_end.\nElements also have begin and end delimiters, though those vary according to context. In our current implementation, the element beginning delimiter is some indentation. The element ending delimiter is the comma character followed by a new line. This is the separator between elements in the table.\nThe indentation amount and the element separator should be user-configurable.\nUsing this terminology, we can rewrite our table_string function:\nfunction table_string(tbl, indent)\n    indent = indent or '    '\n\n    local nl          = indent == '' and '' or '\\n'\n1    local table_begin = '{' .. nl\n    local table_end   = nl .. '}'\n2    local key_begin   = ''\n    local key_end     = ' = '\n3    local sep         = ',' .. nl\n\n4    local content = ''\n    for k, v in pairs(tbl) do\n5        local k_string = key_begin .. tostring(k) .. key_end\n6        local v_string = type(v) ~= 'table' and tostring(v) or table_string(v, indent)\n7        content = content .. indent .. k_string .. v_string .. sep\n    end\n8    return table_begin .. content .. table_end\nend\n\n1\n\nWe introduce the table delimiters as parameters.\n\n2\n\nWe introduce the key delimiters as parameters.\n\n3\n\nWe introduce the element separator as a parameter.\n\n4\n\nCapture the table content in content.\n\n5\n\nAppropriate delimiters surround the key string.  We might cause this to disappear entirely if tbl is a Lua array.\n\n6\n\nThe value string may need to be found using recursion.\n\n7\n\nAdd the current element to the content.\n\n8\n\nFinally, surround the table content with table delimiters.\n\n\nAt first blush, this does not look like an improvement. It is undoubtedly more verbose. However, it is a step towards the goal of supporting many different output formats in one function.\nIf we set key_begin and key_end to '\"' and '\": ' respectively, we get:\n{\n    \"last\": Mouse,\n    \"first\": Minnie,\n\n}\nThis is a good start on JSON output, but we still have the trailing comma problem, and the string values are not enclosed in double-quotes. We’ll return to this later.",
    "crumbs": [
      "Home",
      "Turning the Tables ..."
    ]
  },
  {
    "objectID": "pages/tutorial/index.html#formatting-options",
    "href": "pages/tutorial/index.html#formatting-options",
    "title": "Tutorial: Turning the Tables …",
    "section": "Formatting Options",
    "text": "Formatting Options\nThere are already quite a few parameters at the top of the table_string function that the user might want to set, and more are to come.\nFormatting problems, such as the one here and UI settings for many programs, are notorious for having numerous settable parameters. If a parameter is missing, it should default to some reasonable value.\nWe could continue adding arguments to the function, but that’s not a great idea.\ntable_string(tbl, indent, table_begin, table_end, key_begin, key_end, sep)\nThis calling signature is not user-friendly. It is too verbose and error-prone. It’s easy to forget the arguments’ order or leave one out.\nSome languages have the idea of named arguments, which greatly help in this situation. Lua doesn’t directly support named parameters but has a versatile table object. We can pack all the formatting options into a table and pass that table as a single argument:\ntable_string(tbl, opts)\nopts is a table that holds all our formatting parameters. For example, we might query opts.indent for the desired tab size, etc.\nThe opts argument itself should be optional. For now, we’ll assume that if it is present, it has all the fields we need—it is fully defined.\nLet’s set up a default fallback table of formatting options that might look like this:\nlocal pretty_options = {\n    indent      = '    ',\n    table_begin = '{',\n    table_end   = '}',\n    key_begin   = '',\n    key_end     = ' = ',\n    sep         = ','\n}\nWe should have a few different sets of formatting options. For example, we would like a multiline version, as well as a more compact, inline version. We can set up a table of options for each of these, so let’s start with that pretty version:\n1local options = {}\n2options.pretty = {\n    indent      = '    ',\n    table_begin = '{',\n    table_end   = '}',\n    key_begin   = '',\n    key_end     = ' = ',\n    sep         = ','\n}\n\n1\n\nWe set up a table to hold all our tables of formatting parameters.\n\n2\n\nWe set up a sub-table options.pretty of options for the pretty version.\n\n\nTo use this, our primary table_string function becomes:\n1function table_string(tbl, opts)\n2    opts = opts or options.pretty\n\n3    local indent = opts.indent\n    local nl     = indent == '' and '' or '\\n'\n4    local tb     = opts.table_begin .. nl\n    local te     = nl .. opts.table_end\n5    local kb, ke = opts.key_begin, opts.key_end\n6    local sep    = opts.sep .. nl\n\n    local content = ''\n    for k, v in pairs(tbl) do\n        local k_string = kb .. tostring(k) .. ke\n7        local v_string = type(v) ~= 'table' and tostring(v) or table_string(v, opts)\n        content = content .. indent .. k_string .. v_string .. sep\n    end\n    return tb .. content .. te\nend\n\n1\n\nWe changed the calling signature to incorporate an optional table of formatting parameters.\n\n2\n\nWe use the options.pretty table if’ options’ is absent.\n\n3\n\nGrab the indent field from the opts table.\n\n4\n\nWe unpack the opts table into local variables for convenience where tb is table_begin, etc.\n\n5\n\nWe unpack the opts table into local variables for convenience where kb is key_begin, etc.\n\n6\n\nLocalise the element separator.\n\n7\n\nRemember to pass the opts table to the recursive call!\n\n\nWe can now call print(table_string(mouse)) and get the same output as before:\n{\n    last = Mouse,\n    first = Minnie,\n\n}\nLet’s add a set of options that is specifically for one-line output. We start with a little function to make a shallow clone of any table:\nlocal function table_clone(tbl)\n    local retval = {}\n    for k,v in pairs(tbl) do retval[k] = v end\n    return retval\nend\nThen we can easily set up options.inline:\n1options.inline = table_clone(options.pretty)\n2options.inline.indent = ''\n\n1\n\nWe make a shallow copy of options.pretty and then override the fields we want to change.\n\n2\n\nWe set indent to an empty string.\n\n\nNow we can call print(table_string(mouse, options.inline)) and get:\n1{last = Mouse,first = Minnie,}\n\n1\n\nStill have that pesky trailing comma, but we’ll fix that soon.\n\n\nThe inline version looks cramped. One way to improve things is to add some spaces to the table delimiters and element separator:\noptions.inline = table_clone(options.pretty)\noptions.inline.indent      = ''\n1options.inline.table_begin = '{ '\noptions.inline.table_end   = ' }'\n2options.inline.sep         = ', '\n\n1\n\nAdd some breathing room between the table delimiters and the content.\n\n2\n\nSpace out the table elements.\n\n\nAn alternate approach is to add those spaces on the fly when needed. Some inline formats want to be as compact as possible, so we can make adding those spaces a formatting option:\noptions.pretty = {\n    indent        = '    ',\n    table_begin   = '{',\n    table_end     = '}',\n    key_begin     = '',\n    key_end       = ' = ',\n    sep           = ',',\n1    inline_spacer = ' '\n}\n\noptions.inline = table_clone(options.pretty)\noptions.inline.indent = ''\n\n1\n\nAs the name suggests, inline_spacer controls how generous the spacing is for the inline version of a set of formatting options.\n\n\nHere’s how we use that new formatting field:\nfunction table_string(tbl, opts)\n    opts = opts or options.pretty\n\n    local tb, te = opts.table_begin, opts.table_end\n    local kb, ke = opts.key_begin, opts.key_end\n    local sep    = opts.sep\n    local indent = opts.indent\n\n1    local nl = indent == '' and opts.inline_spacer or '\\n'\n    sep = sep .. nl\n    tb  = tb  .. nl\n    te  = nl  .. te\n\n    local content = ''\n    for k, v in pairs(tbl) do\n        local k_string = kb .. tostring(k) .. ke\n        local v_string = type(v) ~= 'table' and tostring(v) or table_string(v, opts)\n        content = content .. indent .. k_string .. v_string .. sep\n    end\n    return tb .. content .. te\nend\n\n1\n\nIf there is an indentation, then nl is a newline character; otherwise its the user-configurable spacer.\n\n\nFinally, we add a couple of convenience functions that package table_string with a specific set of options:\nfunction pretty(tbl) return\n    table_string(tbl, options.pretty)\nend\n\nfunction inline(tbl)\n    return table_string(tbl, options.inline)\nend\nFor example, print(inline(mouse)) now returns:\n{ last = Mouse, first = Minnie, }\nprint(pretty(mouse)) returns:\n{\n    last = Mouse,\n    first = Minnie,\n\n}\n\n    \n     \n    \n    \nAdding small facade functions like pretty and inline can make the API more user-friendly. Providing a few of these functions for everyday use cases is a good idea.",
    "crumbs": [
      "Home",
      "Turning the Tables ..."
    ]
  },
  {
    "objectID": "pages/tutorial/index.html#the-comma-problem",
    "href": "pages/tutorial/index.html#the-comma-problem",
    "title": "Tutorial: Turning the Tables …",
    "section": "The Comma Problem",
    "text": "The Comma Problem\nIt’s time to eliminate the “comma” problem, which is done by not adding the element separator after the last element.\nLet’s start with Lua arrays, which are tables you can iterate through using indices:\n1for i = 1, #tbl do\n    ...\nend\n\n1\n\n#tbl is a built-in Lua function that returns the number of elements in the array part of tbl.\n\n\nFor arrays, we always know when we are at the last element.\nWe can replace the line that looks like this:\n    ...\n        content = content .. indent .. k_string .. v_string .. sep\n    ...\nwith\n    ...\n        content = content .. indent .. k_string .. v_string\n1        if i + 1 &lt; #tbl then content = content .. sep end\n    ...\n\n1\n\nWe are using i as the current element index, and if we’re at the end of the array, we avoid adding a separator.\n\n\nHowever, we want to handle all Lua tables, which may or may not be arrays. Unfortunately, we cannot rely on #tbl to return the number of elements in a general tbl. If we have the Lua array of strings:\nlocal friends = { \"Mickey\", \"Goofy\" }\nThen #friends will return 2.\nIf, instead, we have a general table that happens to have some key-value elements like:\nlocal mouse_in_characters =\n{\n    'a', 'b', first = \"Minnie\", last = \"Mouse\", 'c', 'd'\n}\nThen #mouse_in_characters returns 4!\nEven though we have deliberately written mouse_in_characters as a couple of key-value elements surrounded by straight array elements, Lua will aggregate the array elements {a, b, c, d} into an array part for the table and, under the covers, keep the two key-value elements in a separate hash map. If you try:\nfor i = 1, #mouse_in_characters do\n    print(mouse_in_characters[i])\nend\nOut pops:\na\nb\nc\nd\nWe cannot access the “dictionary” part of the table this way!\n\n    \n     \n    \n    \nLua tables can be arrays, dictionaries, or both in a single instance! This makes Lua tables very flexible, but it can also be a source of confusion. I suspect it wasn’t a great design decision, as it makes it harder to write general-purpose functions that work with arrays and dictionaries, which are very different data structures. It is what it is, and we must work with it.\n\n\nUsing an Extra Pass\nHowever, we know that the pairs function will access all the table elements:\nfor k, v in  pairs(mouse_in_characters) do\n    print('key', k, 'value', v)\nend\nYields\n1key 1       value   a\nkey 2       value   b\nkey 3       value   c\nkey 4       value   d\n2key last    value   Mouse\nkey first   value   Minnie\n\n1\n\nThe “array” elements will always come first and always in the natural order.\n\n2\n\nThe general key-value elements come next but in an undefined order that changes from run to run.\n\n\nSo, for the price of an extra pass, we can compute the number of elements in any table:\nlocal function table_size(tbl)\n    local size = 0\n    for _,_ in pairs(tbl) do size = size + 1 end\n    return size\nend\nThen print(table_size(mouse_in_characters)) will return 6.\nWe can use table_size in our table_string function:\nfunction table_string(tbl, opts)\n    opts = opts or options.pretty\n\n    local tb, te = opts.table_begin, opts.table_end\n    local kb, ke = opts.key_begin, opts.key_end\n    local sep    = opts.sep\n    local indent = opts.indent\n\n    local nl = indent == '' and opts.inline_spacer or '\\n'\n    sep = sep .. nl\n    tb  = tb  .. nl\n    te  = nl  .. te\n\n    local content = ''\n1    local i, size = 0, table_size(tbl)\n    for k, v in pairs(tbl) do\n2        i = i + 1\n        local k_string = kb .. tostring(k) .. ke\n        local v_string = type(v) ~= 'table' and tostring(v) or table_string(v, opts)\n        content = content .. indent .. k_string .. v_string\n3        if i &lt; size then content = content .. sep end\n    end\n    return tb .. content .. te\nend\n\n1\n\ni’ is the current element index running from 1 to size.\n\n2\n\nIncrement the element “index”.\n\n3\n\nAdd the separator if we are not at the last element.\n\n\nWith this version:\nprint(pretty(mouse))\nYields:\n{\n    first = Minnie,\n1    last = Mouse\n}\n\n1\n\nYeah! That extra comma is gone!\n\n\nprint(inline(mouse)) is also correct:\n{ first = Minnie, last = Mouse }\n\n\nUsing a Guard\nUsing the table_size function means we make an extra pass through the table.\nWe can avoid the extra pass by using a guard variable. While we cannot know when we are at the last element, we do know when we are at the first element. All elements except the first element have a preceding element separator. With that in mind, we can rearrange the main loop in table_string:\nfunction table_string(tbl, opts)\n    opts = opts or options.pretty\n\n    local tb, te = opts.table_begin, opts.table_end\n    local kb, ke = opts.key_begin, opts.key_end\n    local sep    = opts.sep\n    local indent = opts.indent\n\n    local nl = indent == '' and opts.inline_spacer or '\\n'\n    sep = sep .. nl\n    tb  = tb  .. nl\n    te  = nl  .. te\n\n    local content = ''\n1    local first_element = true\n    for k, v in pairs(tbl) do\n2        if first_element then first_element = false else content = content .. sep end\n        local k_string = kb .. tostring(k) .. ke\n        local v_string = type(v) ~= 'table' and tostring(v) or table_string(v, opts)\n        content = content .. indent .. k_string .. v_string\n    end\n    return tb .. content .. te\nend\n\n1\n\nWe initialize first_element to true.\n\n2\n\nIf we’re not at the first element, we start by adding an element-end delimiter before the current element.\n\n\n\n    \n     \n    \n    \nThis is a common idiom in Lua for handling iterations where you must do something special for the final element. Instead, you do something special for the first element and then do the usual thing for all subsequent elements.\n\nThis code version avoids the extra pass and still eliminates the trailing comma.\nprint(pretty(mouse))\nYields:\n{\n    first = Minnie,\n    last = Mouse\n}\n\n    \n     \n    \n    \nComputing the size of tbl does require an extra pass. However, as we shall see shortly, we can use that pass to gather other useful information, so we are happy enough to pay the price of some extra compute cycles.\n\n\n\nEmpty Tables\nWe have one more issue to address. print(pretty({})) returns:\n{\n}\nprint(inline({})) returns:\n{   }\nWe would prefer to see {} in both cases. If we know the size of tbl, then we can add a quick check for an early return at the top of the function,\n1local function empty_table_string(opts)\n2    local retval = (opts.table_begin .. opts.table_end):gsub('%s+', '')\n    return retval\nend\n\nfunction table_string(tbl, opts)\n    opts = opts or options.pretty\n\n    local size = table_size(tbl)\n3    if size == 0 then return empty_table_string(opts) end\n\n    local tb, te = opts.table_begin, opts.table_end\n    local kb, ke = opts.key_begin, opts.key_end\n    local sep    = opts.sep\n    local indent = opts.indent\n\n    local nl = indent == '' and opts.inline_spacer or '\\n'\n    sep = sep .. nl\n    tb  = tb  .. nl\n    te  = nl  .. te\n    local content = ''\n    local i = 0\n    for k, v in pairs(tbl) do\n        i = i + 1\n        local k_string = kb .. tostring(k) .. ke\n        local v_string = type(v) ~= 'table' and tostring(v) or table_string(v, opts)\n        content = content .. indent .. k_string .. v_string\n        if i &lt; size then content = content .. sep end\n    end\n    return tb .. content .. te\nend\n\n1\n\nWe add a helper function to return a string for an empty table, taking into account the table delimiters.\n\n2\n\nIt does that by concatenating the table delimiters and then using gsub to remove all whitespace.\n\n3\n\nIn our table_string function we look for an early exit for empty tables.\n\n\nWith this change in place, print(pretty({})) and print(inline({})) both return {}.",
    "crumbs": [
      "Home",
      "Turning the Tables ..."
    ]
  },
  {
    "objectID": "pages/tutorial/index.html#arrays-vs.-tables",
    "href": "pages/tutorial/index.html#arrays-vs.-tables",
    "title": "Tutorial: Turning the Tables …",
    "section": "Arrays vs. Tables",
    "text": "Arrays vs. Tables\nLua has one type of table. It can be an array, a dictionary, or a mix of both. Under the covers, Lua keeps the array part separate from the dictionary part for efficiency.\nMost programming languages have a distinct array type, and differentiating between arrays and dictionaries is often crucial.\nFor example, JSON is a popular human-readable data exchange format with a separate array type. In JSON, arrays are always ordered and have implicit keys that are consecutive integers. They are represented by square brackets [ ... ] to distinguish them from dictionaries represented by curly braces { ... }.\nWe can easily write a small function to determine whether a table is an array or a dictionary:\nlocal function table_is_array(tbl)\n    local size = 0\n    for _,_ in pairs(tbl) do\n        size = size + 1\n1        if tbl[size] == nil then return false end\n    end\n2    return true\nend\n\n1\n\nArrays are indexed by consecutive integers from 1. If we find a hole, we know that tbl is not an array.\n\n2\n\nIf we make it through the loop without finding a hole, we know that tbl is an array.\n\n\nIf tbl is a Lua array, a complete pass through tbl is required to confirm it is an array. We can add the check to our existing table_size function, which we rename metadata:\nlocal function metadata(tbl)\n    local size = 0\n1    local array = true\n    for _,_ in pairs(tbl) do\n        size = size + 1\n2        if array and tbl[size] == nil then array = false end\n    end\n3    return size, array\nend\n\n1\n\nWe assume tbl is an array until we find otherwise.\n\n2\n\nIf we find a “hole”, then tbl is not an array.\n\n3\n\nReturn both the computed size and array values.\n\n\n\n    \n     \n    \n    \nLua functions can return multiple values. This feature can be handy, but you don’t want to overdo it, as the function’s caller needs to get the order of the returned values right. Correct ordering is not a problem for two or even three values. After that, it is best to put the returns in a name-value table.\n\n\n    \n     \n    \n    \nWe use metadata to indicate that we are returning more than the table size. We will add other bits of metadata as we go along. Do not confuse this with Lua’s metatable concept, which allows you to override the behaviour standard operators like +, -, etc. and the behaviour of methods like tostring, print, etc.\n\nWe can add some array delimiters to our option tables:\noptions.pretty = {\n    indent        = '    ',\n    table_begin   = '{',\n    table_end     = '}',\n1    array_begin   = '[',\n    array_end     = ']',\n    key_begin     = '',\n    key_end       = ' = ',\n    sep           = ',',\n    inline_spacer = ' '\n}\n\n1\n\nWe will differentiate arrays by using square bracket delimiters.\n\n\nLet’s put the new metadata method to use in the main event:\nfunction table_string(tbl, opts)\n    opts = opts or options.pretty\n\n1    local size, array = metadata(tbl)\n    if size == 0 then return empty_table_string(opts) end\n\n2    local tb     = array and opts.array_begin or opts.table_begin\n    local te     = array and opts.array_end or opts.table_end\n    local kb, ke = opts.key_begin, opts.key_end\n    local sep    = opts.sep\n    local indent = opts.indent\n\n    local nl = indent == '' and opts.inline_spacer or '\\n'\n    sep = sep .. nl\n    tb  = tb  .. nl\n    te  = nl  .. te\n\n    local content = ''\n    local i = 0\n    for k, v in pairs(tbl) do\n        i = i + 1\n        local k_string = kb .. tostring(k) .. ke\n        local v_string = type(v) ~= 'table' and tostring(v) or table_string(v, opts)\n        content = content .. indent .. k_string .. v_string\n        if i &lt; size then content = content .. sep end\n    end\n    return tb .. content .. te\nend\n\n1\n\nmetadata returns the size and the type tbl.  The order is fixed.\n\n2\n\nWe can pick suitable table delimiters depending on whether tbl is an array.\n\n\nNow print(pretty(mouse)) returns:\n{\n    last = Mouse,\n    first = Minnie\n}\nwhile print(pretty(friends)) returns:\n1[\n2    1 = Mickey,\n    2 = Goofy\n]\n\n1\n\nArrays are now delimited with square brackets.\n\n2\n\nHowever, we are outputting the array indices 1, 2, ..., which is generally unnecessary.\n\n\nLua has “keys” for all table elements. In the case of arrays, those keys are the array indices, which are consecutive integers starting at 1. You don’t usually need to see those, so we alter our function only to show keys if tbl is not an array.\nfunction table_string(tbl, opts)\n    ...\n    for k, v in pairs(tbl) do\n        ...\n1        if not array then content = content .. kb .. tostring(k) .. ke end\n        ...\n    end\n    ...\n    return retval\nend\n\n1\n\nNow, we don’t show keys for array tables.\n\n\nNow print(pretty(friends)) returns:\n[\n    Mickey,\n    Goofy\n]\nThe output from print(pretty(mouse)) remains unchanged:\n{\n    last = Mouse,\n    first = Minnie\n}\nSometimes, you need to see the “keys:” for an array. For example, if you are debugging and want to see the array indices. Let’s add an option to show the keys for arrays:\noptions.pretty = {\n    indent        = '    ',\n    table_begin   = '{',\n    table_end     = '}',\n    array_begin   = '[',\n    array_end     = ']',\n    key_begin     = '',\n    key_end       = ' = ',\n    sep           = ',',\n    inline_spacer = ' ',\n1    show_indices  = false\n}\n\n1\n\nTypically, we suppress seeing array indices.\n\n\nThe corresponding change to table_string is straightforward:\nfunction table_string(tbl, opts)\n    opts = opts or options.pretty\n\n    local size, array = metadata(tbl)\n    if size == 0 then return empty_table_string(opts) end\n1    local show_keys = not array and true or opts.show_indices\n    ...\n    for k, v in pairs(tbl) do\n        i = i + 1\n2        local k_string = show_keys and kb .. tostring(k) .. ke or ''\n        ...\n    end\n    ...\n    return retval\nend\n\n1\n\nWe set show_keys to true unless we are dealing with an array, in which case we use whatever is dictated by opts.show_indices.\n\n2\n\nWe only show keys if show_keys is true.  That is always the case for non-arrays and is user-settable for arrays.\n\n\nWith that change, print(inline(friends)) returns [ Mickey, Goofy ]. If you set opts.show_indices = true, then print(inline(friends)) returns [ 1 = Mickey, 2 = Goofy ].\nFinally, let’s add a couple of sets of formatting options that don’t include separate array delimiters. This is the style you most often see in Lua code, so it is handy to have it available.\noptions.classic = table_clone(options.pretty)\n1options.classic.array_begin = '{'\noptions.classic.array_end   = '}'\n\n2function classic(tbl)\n    return table_string(tbl, options.classic)\nend\n\n1\n\nAll tables use the same delimiters { ... }.\n\n2\n\nWe add a convenience function, classic, that uses the options.classic.\n\n\nNow print(classic(friends)) returns\n{\n    Mickey,\n    Goofy\n}",
    "crumbs": [
      "Home",
      "Turning the Tables ..."
    ]
  },
  {
    "objectID": "pages/tutorial/index.html#adding-indentation",
    "href": "pages/tutorial/index.html#adding-indentation",
    "title": "Tutorial: Turning the Tables …",
    "section": "Adding Indentation",
    "text": "Adding Indentation\nEarlier, we alluded that while our solution does something for nested sub-tables by recursion, it certainly gets indentation screwed up in the process.\nSuppose we introduce a table that captures Minnie’s “user profile” and try to print it:\nlocal user =\n{\n    first = \"Minnie\",\n    last = \"Mouse\",\n1    friends = { \"Mickey\", \"Goofy\" }\n}\n\n1\n\nMinnie’s friends are captured in an array.\n\n\nThen, print(pretty(user)) might yield:\n{\n    first = Minnie,\n1    friends = [\n    Mickey,\n    Goofy\n],\n    last = Mouse\n}\n\n1\n\nWe see friends as a nice array, but the indentation is incorrect.\n\n\nIdeally, we’d like to see:\n{\n    friends = [\n        Mickey,\n        Goofy\n    ],\n    first = Minnie,\n    last = Mouse\n}\nOur current output is readable but gets less and less with larger tables and more nesting. Deeper nesting requires more indentation! We better fix that next.\nThe most straightforward idea is to add indentation to the string returned from the recursive call table_string(v, opts).\nWe can make a function that adds indentation line-by-line to any Lua string:\nlocal function indent_string(str, indent)\n1    if not indent or indent == \"\" or not str or str == \"\" then return str end\n2    local ends_with_newline = str:sub(-1) == \"\\n\"\n    local indented_str = \"\"\n3    local first_line = true\n4    for line in str:gmatch(\"([^\\n]*)\\n?\") do\n5        if not first_line then indented_str = indented_str .. \"\\n\" end\n        indented_str = indented_str .. indent .. line\n        first_line = false\n    end\n6    if ends_with_newline then indented_str = indented_str .. \"\\n\" end\n    return indented_str\nend\n\n1\n\nHandle some edge cases, as we do not need to do anything if the indent is the empty string. This check allows downstream methods to call indent_string without worrying that it will do something stupid.\n\n2\n\nWe will add the indentation line-by-line. If the input str ends with a new line, the output should also.\n\n3\n\nThis looks like that guard “trick” we discussed earlier.\n\n4\n\nHere, we iterate through str line-by-line with an unknown number of hits using Lua’s pattern search function gmatch.\n\n5\n\nAdd newline characters to all but the first line.\n\n6\n\nMatch the input — if it ends with a new line, the output will also.\n\n\n\nAside: Lua Patterns\nThe gmatch method added to the string class is another type of iterator. In this case, it looks for a pattern in the string str and returns the next match. When it can find no more matches, it returns nil and the iteration loop finishes.\nLua string patterns are like regular expressions in other languages, though they use fewer features. For example, if we have the string \"ho,  ho, ho\" then the pattern \"ho\" matches the literal character 'h' followed immediately by 'o'. We might use it like this:\nlocal str = \"ho, ho, ho\"\nlocal count = 0\nfor _ in str:gmatch(\"ho\") do\n    count = count + 1\n    print(\"Found\", count)\nend\nThat will output:\nFound 1\nFound 2\nFound 3\nOf course, if gmatch and friends could only find literal matches, they wouldn’t be powerful enough for most applications. While Lua’s pattern-matching library is slim, fortunately, it’s not that slim. Lua patterns can encompass classes of characters instead of literal ones.\nIn the indent_string function, the pattern we successively match on is \"([^\\n]*)\\n?\". This has many characteristic elements of a regular expression: it is terse and full of punctuation characters!\nIf you remove the parentheses, you have \"[^\\n]*\\n?\". The first part \"[^\\n]\" simply says to look for a substring that starts with either the beginning of the string (denoted by the magic character, the caret '^') or the newline character '\\n'. In patterns, you create “ors” with square brackets, so \"[xyz]\" will match on 'x' or 'y' or 'z'. The next part, ’ “?“starts with another magic character’’that matches *anything*. The‘?’` is another magic incantation; in this case, it tells the pattern matcher that the previous character (the newline character) is optional.\nIn all, the `“[^\\n]*?” pattern says to match on a substring that starts at the beginning of the string or a newline character and finishes when you hit a newline character or run out of string.\nThe only thing missing is telling the pattern-matching engine which bits of the pattern constitute the substring we want. What should the pattern matcher capture?\nThat is what the parentheses are used for. The engine will capture whatever you put inside parentheses. In this case, we have parentheses around the first bit \"([^\\n]*)\\n?\" so we capture everything from either the string start or a newline character until we hit a newline character or the end of the string. In other words, we capture a line in the string. The g in gmatch stands for “global,” so it doesn’t stop at the first line but keeps iterating through the whole string line by line.\n\n\nIndenting Tables\nWith the indent_string method in place, we can rewrite our primary function:\nfunction table_string(tbl, opts)\n    ...\n    for k, v in pairs(tbl) do\n        ...\n        local v_string = ''\n        if type(v) == 'table' then\n            v_string = table_string(v, opts)\n            v_string = indent_string(v_string, indent)\n        else\n            v_string = tostring(v)\n        end\n        ...\n    end\n    ...\n    return retval\nend\nWith those changes, we can call print(pretty(user)) and get:\n{\n    friends =     [\n        Mickey,\n        Goofy\n    ],\n    last = Mouse,\n    first = Minnie\n}\nThe elements in the friends array are now indented correctly, but the opening brace is also indented.\nWe can alter our indent_string function to ignore the first line optionally:\n1local function indent_string(str, indent, ignore_first_line)\n2    ignore_first_line = ignore_first_line or false\n    if not indent or indent == \"\" or not str or str == \"\" then return str end\n    local ends_with_newline = str:sub(-1) == \"\\n\"\n    local indented_str = \"\"\n    local first_line = true\n    for line in str:gmatch(\"([^\\n]*)\\n?\") do\n        if not first_line then indented_str = indented_str .. '\\n' end\n        local tab = first_line and ignore_first_line and '' or indent\n        indented_str = indented_str .. tab .. line\n        first_line = false\n    end\n    if ends_with_newline then indented_str = indented_str .. \"\\n\" end\n    return indented_str\nend\n\n1\n\nWe have added an optional boolean parameter ignore_first_line to the function.\n\n2\n\nIf the user doesn’t provide a value for ignore_first_line, we default to false.\n\n\nWith those changes, we can call print(pretty(user)) and get:\n{\n    friends = [\n        Mickey,\n        Goofy\n    ],\n    last = Mouse,\n    first = Minnie\n}\nThe inline format print(inline(user)) is also correct:\n{ last = Mouse, first = Minnie, friends = [ Mickey, Goofy ] }",
    "crumbs": [
      "Home",
      "Turning the Tables ..."
    ]
  },
  {
    "objectID": "pages/tutorial/index.html#other-output-formats",
    "href": "pages/tutorial/index.html#other-output-formats",
    "title": "Tutorial: Turning the Tables …",
    "section": "Other Output Formats",
    "text": "Other Output Formats\nWe will look at a few other formats commonly used for viewing tables.\n\nIndentation Only\nAnother commonly used multiline table format avoids delimiters and instead relies on indentation to show the structure. Here is how our user table would look in this format:\nlast: Mouse,\nfirst: Minnie,\n1friends:\n    Mickey,\n    Goofy\n\n1\n\nThis all looks straightforward, but this format is tricky to implement.\n\n\nWe add a new set of formatting options for this format:\noptions.alt = table_clone(options.pretty)\noptions.alt.table_begin = ''\noptions.alt.table_end   = ''\noptions.alt.array_begin = ''\noptions.alt.array_end   = ''\noptions.alt.key_end     = ': '\nNothing too wild here; we start with options.pretty and set the table/array delimiters to blank strings. We also set up colons to act as the assignment operators.\nWe also add the usual convenience function that packages those formatting options with table_string:\nfunction alt(tbl)\n    return table_string(tbl, options.alt)\nend\nIf we try print(alt(user)) we get something like:\n1    first: Minnie,\n    last: Mouse,\n    friends:\n        Mickey,\n Goofy\n\n1\n\nAn extra indentation layer isn’t needed when the table delimiters are blank.\n\n2\n\nThere are also some extra newlines at the end of the output.\n\n\nA first attempt at fixing this format is to remove the indentation from the top-level elements. We can do this by adding a check for a blank table begin-delimiter:\nfunction table_string(tbl, opts)\n    opts = opts or options.pretty\n\n    local size, array = metadata(tbl)\n    if size == 0 then return empty_table_string(opts) end\n    local show_keys = not array and true or opts.show_indices\n\n    local tb     = array and opts.array_begin or opts.table_begin\n    local te     = array and opts.array_end or opts.table_end\n    local kb, ke = opts.key_begin, opts.key_end\n    local sep    = opts.sep\n    local indent = opts.indent\n    local nl     = indent == '' and opts.inline_spacer or '\\n'\n\n1    if tb ~= '' then tb = tb .. nl end\n2    if te ~= '' then te = nl .. te end\n3    sep = sep .. nl\n\n    local no_delims = tb == ''\n4    if no_delims then indent = '' end\n\n    local content = ''\n    local i = 0\n    for k, v in pairs(tbl) do\n        i = i + 1\n        local k_string = show_keys and kb .. tostring(k) .. ke or ''\n        local v_string = ''\n        if type(v) == 'table' then\n            v_string = table_string(v, opts)\n5            v_string = indent_string(v_string, opts.indent, true)\n        else\n            v_string = tostring(v)\n        end\n        content = content .. indent .. k_string .. v_string\n        if i &lt; size then content = content .. sep end\n    end\n    return tb .. content .. te\nend\n\n1\n\nWe add a new line to the table begin-delimiter if we use multiline output and the table begin-delimiter is not blank.\n\n2\n\nWe add a new line to the table end-delimiter if we use multiline output and the table end-delimiter is not blank.\n\n3\n\nWe add a new line to the separator if we are using multiline output.\n\n4\n\nIf the table begin-delimiter is blank, we don’t indent the top-level elements in tbl.\n\n5\n\nWe still indent any sub-table elements with the “real” indentation amount from the formatting options.\n\n\nWith that in place, print(alt(user)) returns something unindented at the outermost level and without the extra newlines at the end:\nfirst: Minnie,\nlast: Mouse,\n1friends: Mickey,\n    Goofy\n\n1\n\nThere should be a new line after friends here.\n\n\nWe are missing a newline character before the sub-array of friends. It should only be present if the table is multiline and the begin-delimiter is blank. This suggests a small addition to the table_string function:\nfunction table_string(tbl, opts)\n    ...\n    for k, v in pairs(tbl) do\n        ...\n        if type(v) == 'table' then\n            v_string = table_string(v, opts)\n1            if tb == '' then v_string = nl .. v_string end\n        ...\n    end\n    return tb .. content .. te\nend\n\n1\n\nThe suggested fix.\n\n\nHowever, this doesn’t quite work as expected as print(alt(user)) now returns:\nlast: Mouse,\nfirst: Minnie,\nfriends:\n1Mickey,\n    Goofy\n\n1\n\nWe’re missing an indentation on the Mickey line.\n\n\nHowever, we can fix this by using that third ignore_first_line argument in indent_string:\nfunction table_string(tbl, opts)\n    ...\n    for k, v in pairs(tbl) do\n        ...\n        if type(v) == 'table' then\n            v_string = table_string(v, opts)\n1            v_string = indent_string(v_string, opts.indent, not no_delims)\n2            if no_delims and show_keys then v_string = nl .. v_string end\n        ...\n    end\n    return tb .. content .. te\nend\n\n1\n\nWe skip indenting the first line of the sub-table unless the table begin-delimiter is blank.\n\n2\n\nWe add a newline character if the table begin-delimiter is blank and we are showing keys.\n\n\nThe full table_string function now looks like:\nfunction table_string(tbl, opts)\n    opts = opts or options.pretty\n\n    local size, array = metadata(tbl)\n    if size == 0 then return empty_table_string(opts) end\n    local show_keys = not array and true or opts.show_indices\n\n    local tb     = array and opts.array_begin or opts.table_begin\n    local te     = array and opts.array_end or opts.table_end\n    local kb, ke = opts.key_begin, opts.key_end\n    local sep    = opts.sep\n    local indent = opts.indent\n    local nl     = indent == '' and opts.inline_spacer or '\\n'\n\n    sep = sep .. nl\n    if tb ~= '' then tb = tb .. nl end\n    if te ~= '' then te = nl .. te end\n\n    local no_delims = tb == ''\n    if no_delims then indent = '' end\n\n    local content = ''\n    local i = 0\n    for k, v in pairs(tbl) do\n        i = i + 1\n        local k_string = show_keys and kb .. tostring(k) .. ke or ''\n        local v_string = ''\n        if type(v) == 'table' then\n            v_string = table_string(v, opts)\n            v_string = indent_string(v_string, opts.indent, not no_delims)\n            if no_delims and show_keys then v_string = nl .. v_string end\n        else\n            v_string = tostring(v)\n        end\n        content = content .. indent .. k_string .. v_string\n        if i &lt; size then content = content .. sep end\n    end\n    return tb .. content .. te\nend\nWith this change in place print(alt(user)) returns something like:\n1last: Mouse,\nfirst: Minnie,\nfriends:\n    Mickey,\n    Goofy\n\n1\n\nThe elements can be ordered differently.\n\n\nThe other formats still work as expected. print(pretty(user)) returns:\n{\n    last = Mouse,\n    first = Minnie,\n    friends = [\n        Mickey,\n        Goofy\n    ]\n}\nprint(inline(user)) returns:\n{ last = Mouse, first = Minnie, friends = [ Mickey, Goofy ] }\n\n\nJSON\nThe JSON format is a popular format for exchanging data between systems. Like our pretty format, JSON delimits tables with curly braces and arrays with square brackets. It surrounds keys with double quotes and uses colons to separate keys from values.\nLet’s add a new set of formatting options for JSON:\noptions.json = table_clone(options.pretty)\noptions.json.key_begin = '\"'\noptions.json.key_end   = '\": '\nWe also add the usual convenience function that packages those formatting options with table_string:\nfunction json(tbl)\n    return table_string(tbl, options.json)\nend\n\nIf we try `print(alt(user))` we get:\n```txt\n{\n    \"last\": Mouse,\n    \"first\": Minnie,\n    \"friends\": [\n        Mickey,\n        Goofy\n ]\n}\nThis isn’t quite JSON, as JSON requires string values to be surrounded by double quotes.\nIn fact, it is a good idea to always surround string values with double quotes. Lua’s string class has a string.format method that is perfect for this task.\nFor example, string.format(\"Hello, %s!\", \"world\") returns \"Hello, world!\". The %s is a placeholder for a string value that is passed as a trailing argument to string.format. string.format is a wrapper around the venerable C function sprintf and uses almost all the same format specifiers. So %s is used for strings, %d for integers, and %f for floating-point numbers etc.\nOne of Lua’s primary use cases is dealing with large amounts of text that often includes multiline strings. It is useful to be able to see those in their raw form. For that reason, Lua has a special format specifier %q that is used to quote strings. It is similar to %s but it adds double quotes around the string and escapes any special characters. For example, string.format(\"%q\", 'Hello, \"world\"!') returns '\"Hello, \\\"world\\\"!\"'.\nWe can use this format specifier to good effect. While at it, we will add a simple_string counterpart to table_string to take any Lua object and return a simple string representation.\n1local function simple_string(obj)\n    if obj == nil then return 'nil' end\n    local obj_type = type(obj)\n2    if obj_type == 'number' or obj_type == 'boolean' or obj_type == nil then\n        return tostring(obj)\n    elseif obj_type == 'string' then\n3        return string.format(\"%q\", obj)\n    elseif obj_type == 'table' then\n4        return string.format(\"%p\", obj)\n    elseif obj_type == 'function' then\n        return '&lt;function&gt;'\n    elseif obj_type == 'userdata' then\n        return '&lt;userdata&gt;'\n    elseif obj_type == 'thread' then\n        return '&lt;thread&gt;'\n    else\n5        return '&lt;UNKNOWN type: ' .. tostring(obj) .. '&gt;'\n    end\nend\n\n1\n\nThe new function simple_string takes any Lua object and returns a simple string representation of it.\n\n2\n\nWe let tostring handle numbers, booleans, and nil values.\n\n3\n\nWe use string.format with the %q format specifier to quote strings.\n\n4\n\nWe use string.format with the %p format specifier to print the memory address of a table.  We will usually defer table conversion to table_string.\n\n5\n\nWe should never reach this point, but add a catch-all for unknown types that Lua might introduce.\n\n\nWe can now use simple_string in our table_string function:\nfunction table_string(tbl, opts)\n    ...\n    local i, content = 0, ''\n    for k, v in pairs(tbl) do\n        i = i + 1\n1        local k_string = show_keys and kb .. tostring(k) .. ke or ''\n        local v_string = ''\n        if type(v) == 'table' then\n            ...\n        else\n2            v_string = simple_string(v)\n        end\n        ...\n    end\n    return tb .. content .. te\nend\n\n1\n\nWe still use tostring to convert keys to strings and rely on key delimiters to add quotes if needed.\n\n2\n\nWe use simple_string to convert non-table values to strings, so always get double quotes around strings.\n\n\nWith this change in place print(json(user)) returns:\n{\n    \"last\": \"Mouse\",\n    \"first\": \"Minnie\",\n    \"friends\": [\n        \"Mickey\",\n        \"Goofy\"\n    ]\n}\n\n\nCompact JSON\nWhile JSON is often used in its pretty format, it is common to use a more compact format where all extra spaces and newlines are removed.\nWe can add a new set of formatting options for inline JSON:\noptions.inline_json = table_clone(options.json)\noptions.inline_json.indent        = ''\noptions.inline_json.key_end       = '\":'\n1options.inline_json.inline_spacer = ''\n\n1\n\nIn this case, we remove the inline spacer as well to make the output even more compact.\n\n\nWe also add the usual convenience function that packages those formatting options with table_string:\nfunction inline_json(tbl)\n    return table_string(tbl, options.inline_json)\nend\nIf we try print(inline_json(user)) we get:\n{\"last\":\"Mouse\",\"first\":\"Minnie\",\"friends\":[\"Mickey\",\"Goofy\"]}\nThis is also a valid JSON format, but it is harder to read for humans.\n\n\nDebug Format\nWe can add a set of formatting options that makes the structure of the table explicit. This can be useful when you are trying to add a custom set of formatting options:\noptions.debug = table_clone(options.pretty)\noptions.debug = table_clone(options.pretty)\noptions.debug.indent        = ' INDENT '\noptions.debug.table_begin   = 'TABLE BEGIN'\noptions.debug.table_end     = 'TABLE END'\noptions.debug.array_begin   = 'ARRAY BEGIN'\noptions.debug.array_end     = 'ARRAY END'\noptions.debug.key_begin     = ' KEY BEGIN '\noptions.debug.key_end       = ' KEY END = '\noptions.debug.sep           = ' SEP '\noptions.debug.show_indices  = true\nAs usual, we add the convenience function that packages those formatting options with table_string:\nfunction debug(tbl)\n    return table_string(tbl, options.debug)\nend\nIf we try print(debug(user)) we get:\nTABLE BEGIN\n INDENT  KEY BEGIN first KEY END = \"Minnie\" SEP\n INDENT  KEY BEGIN last KEY END = \"Mouse\" SEP\n INDENT  KEY BEGIN friends KEY END = ARRAY BEGIN\n INDENT  INDENT  KEY BEGIN 1 KEY END = \"Mickey\" SEP\n INDENT  INDENT  KEY BEGIN 2 KEY END = \"Goofy\"\n INDENT ARRAY END\nTABLE END",
    "crumbs": [
      "Home",
      "Turning the Tables ..."
    ]
  },
  {
    "objectID": "pages/tutorial/index.html#ordered-output",
    "href": "pages/tutorial/index.html#ordered-output",
    "title": "Tutorial: Turning the Tables …",
    "section": "Ordered Output",
    "text": "Ordered Output\nLua has a single table type. However, as talked about several times now, under the covers, Lua distinguishes between the array part of a table and any dictionary part it might contain. The elements in a Lua array are in fixed constant order so that if:\nlocal arr = { 'a', 'b', 'c' }\nThen, print(inline(arr)) will always print ['a', 'b', 'c'].\nIn contrast, the element order in a general key-value table is not defined or constant. If we have:\nlocal mouse = { first = 'Minnie', last = 'Mouse' }\nThen, print(inline(mouse)) will sometimes display { last = Mouse, first = Minnie, }, other times { first = Minnie, last = Mouse, }.\nJumping around like that can be disconcerting.\nSo far, we have used the Lua standard pairs function to traverse through the key-value pairs in all tables.\n    for k, v in pairs(tbl) do\n        ...\n    end\nLua provides an efficient iterator function, ipairs, specifically for arrays. We can alter our iteration based on whether the table is an array or a key-value table and get a little performance boost.\n    local iter = array and ipairs or pairs\n    for k, v in iter(tbl) do\n        ...\n    end\nOf course, ipairs doesn’t solve the problem of inconsistent output for key-value tables.\nFortunately, Lua lets us define custom iterator functions, and we can create one to iterate over the keys in a consistent order.\n1    local iter = array and ipairs or ordered_pairs\n    for k, v in tbl(tbl) do\n        ...\n    end\n\n1\n\nWe have replaced the standard pairs iterator with a custom ordered_pairs function.  We still use ipairs for arrays.\n\n\nA custom iterator function is passed a table and should return the “next” key-value pair in the table. The function should return nil if no more key-value pairs exist. You are free to determine what “next” means in this context.\nHere is a simple implementation of ordered_pairs:\nlocal function ordered_pairs(tbl)\n    local keys = {}\n1    for k in pairs(tbl) do table.insert(keys, k) end\n2    table.sort(keys)\n    local i = 0\n3    return function()\n4        i = i + 1\n5        return keys[i], tbl[keys[i]]\n    end\nend\n\n1\n\nWe capture all the keys from tbl in the keys array.\n\n2\n\nThe default behaviour for table.sort is alphabetical sorting.  However, table.sort can take a comparison function as a second argument if you want to sort the keys in a different order.\n\n3\n\nThe ordered_pairs function returns an iterator which is itself a function.\n\n4\n\nThe iterator function is a closure, so it has access to the keys and the current index i from the enclosing function.\n\n5\n\nThe iterator increments the index i and returns the corresponding key-value pair from tbl.  The iterator will return nil, nil when there are no more elements, but you could put in an explicit check on i if you wanted to.\n\n\nThis version of ordered_keys assumes that the keys are all the same type, which is too limiting. The table.sort call will fail if they aren’t. A comparison function takes two arguments and returns true if the first argument should come before the second. We can make a default one that works for all types:\nlocal function compare(a, b)\n    local ta, tb = type(a), type(b)\n    if ta ~= tb then\n        return ta &lt; tb\n    elseif ta == 'table' or ta == 'boolean' or ta == 'function' then\n        return tostring(a) &lt; tostring(b)\n    else\n        return a &lt; b\n    end\nend\nThis function sorts keys first by type and then by value. We note that alphabetically, number comes before string, so we will see numbers before strings, which is the standard convention.\nWe could use this function in ordered_pairs:\nlocal function ordered_pairs(tbl)\n    ...\n1    table.sort(keys, compare)\n    ...\nend\n\n1\n\nWe sort the keys using the comparison function compare.\n\n\nHowever, the user may want to define a custom comparison function. For example, they might want to sort the keys case-insensitively or in reverse alphabetical order.\nIdeally, we want the user to be able to pass a comparison function to ordered_pairs and have it return an iterator maker that can use that comparator to iterate over any table in a consistent order.\nAn extra level of indirection is required:\n1local function ordered_pairs(comparator)\n2    if comparator == false then return pairs end\n3    comparator = comparator or compare\n4    return function(tbl)\n        local keys = {}\n        for k, _ in pairs(tbl) do table.insert(keys, k) end\n5        table.sort(keys, comparator)\n        local i = 0\n6        return function()\n            i = i + 1\n            return keys[i], tbl[keys[i]]\n        end\n    end\nend\n\n1\n\nWe have added a comparator argument, which should be a function that takes two keys and returns true if the first key should come before the second.\n\n2\n\nIf comparator is explicitly set to false, we return the standard pairs iterator.\n\n3\n\nIf comparator is missing, we use the compare.\n\n4\n\nWe return a function that takes a table and returns an iterator function for that table using the sorted keys.\n\n5\n\nWe sort the keys using comparator, which will be set by now.\n\n6\n\nThe iterator function is a closure with access to the sorted keys and the current index.\n\n\n\n    \n     \n    \n    \nAdding a layer of indirection is another typical pattern in programming. Our ordered_pairs is a function that returns a function that returns a function.\n\nWe add a comparator field to the options.pretty table:\nlocal options = {}\noptions.pretty = {\n    indent        = '    ',\n    table_begin   = '{',\n    table_end     = '}',\n    array_begin   = '[',\n    array_end     = ']',\n    key_begin     = '',\n    key_end       = ' = ',\n    sep           = ',',\n    inline_spacer = ' ',\n    show_indices  = false,\n1    comparator    = compare\n}\n\n1\n\nWe use the default comparison function unless the user specifies otherwise.\n\n\n\n    \n     \n    \n    \nThe user can set the comparator field to false if they want to use the standard pairs iterator.\n\n\nAside: nil vs. false\nLike many older languages, Lua treats nil as false in a conditional test.\nHowever, false is a distinct value in Lua. It is a boolean that is false in a conditional test. In Lua, nil represents the absence of a value. false represents a value that is explicitly false.\nChoosing to treat nil as false in a conditional test probably seemed convenient. It is a common idiom in many languages, particularly C, where 0 can represent false. Modern languages have moved away from this.\nThis conflating of nil and false can lead to subtle bugs. This is particularly true in Lua, where you will likely have functions with optional arguments. The common idiom for optional arguments looks like this:\nlocal function foo(arg)\n    arg = arg or 'default'\n    print(arg)\nend\nIf arg is missing or nil, it will be set to 'default'. If arg is explicitly false, it will still be set to 'default' which is probably not what you want.\nTry it:\nfoo()           -- prints 'default'\nfoo(nil)        -- prints 'default'\nfoo('hello')    -- prints 'hello'\n1foo(false)      -- prints 'default'\n\n1\n\nThis is not what you want!\n\n\nFrom personal experience, this will bite you at some point.\nYou sometimes might want to distinguish between the absence of an argument and an explicitly false argument. We can rewrite foo to handle this:\nlocal function foo(arg)\n1    if arg == false then print('false') end\n    arg = arg or 'default'\n    print(arg)\nend\n\nfoo()           -- prints 'default'\nfoo(nil)        -- prints 'default'\nfoo('hello')    -- prints 'hello'\nfoo(false)      -- prints 'false'\n\n1\n\nWe added a check for arg being explicitly false.\n\n\n\n\nOrdered Output Resolved\nThe change to table_string is quite small:\nfunction table_string(tbl, opts)\n    ...\n1    local iter = array and ipairs or ordered_pairs(opts.comparator)\n    for k, v in iter(tbl) do\n        ...\n    end\n    ...\nend\n\n1\n\nWe have replaced the pairs iterator with ordered_pairs using a user-defined comparison function for non-arrays.\n\n\nNow if you try print(pretty(user)) you always get:\n1{\n    first = Minnie,\n2    friends = [\n        Mickey,\n        Goofy\n    ],\n    last = Mouse\n}\n\n1\n\nuser is a key-value table, and the elements are shown with the keys alphabetically.\n\n2\n\nfriends is a sub-array with the elements shown in index order.",
    "crumbs": [
      "Home",
      "Turning the Tables ..."
    ]
  },
  {
    "objectID": "pages/tutorial/index.html#inlining-simple-sub-tables",
    "href": "pages/tutorial/index.html#inlining-simple-sub-tables",
    "title": "Tutorial: Turning the Tables …",
    "section": "Inlining Simple Sub-Tables",
    "text": "Inlining Simple Sub-Tables\nA nice feature of some pretty-printers is the ability to inline “simple” sub-tables. This option can make the output more readable and compact.\nOf course, we need to define what “simple” means. It could be a small table that fits inside a set number of characters. Or it could be a table with a certain number of elements.\nFor our purposes, we will consider a table “simple” if it has no sub-tables. We will also add an optional limit on the number of elements to this definition.\nWe can alter our metadata function to return the number of sub-tables in a table:\nlocal function metadata(tbl)\n    local size = 0\n    local array = true\n1    local subs = 0\n    for _, v in pairs(tbl) do\n        size = size + 1\n        if array and tbl[size] == nil then array = false end\n2        if type(v) == 'table' then subs = subs + 1  end\n    end\n3    local md = { size = size, array = array, subs = subs }\n4    return md\nend\n\n1\n\nsubs will be the number of sub-tables.\n\n2\n\nIf we find a sub-table, we increment subs.\n\n3\n\nInstead of returning three values, we create a table with three fields.\n\n4\n\nWe return the metadata table.\n\n\nIf you haven’t seen this coding style before, the md table is created with a table constructor. It is a shorthand way to create a table with some initial values. Assignments of the form tbl = { x = x } look odd, but they are a common idiom in Lua. The assignment is shorthand for tbl[x] = x where the x key is a string, and the x value can be any type.\nWe can now use the subs field in our table_string method to decide whether to inline a sub-table.\nHowever, whether or not to inline simple tables should also be user-configurable. To accommodate that, we can add another field to our options table.\nlocal options = {}\noptions.pretty = {\n    indent        = '    ',\n    table_begin   = '{',\n    table_end     = '}',\n    array_begin   = '[',\n    array_end     = ']',\n    key_begin     = '',\n    key_end       = ' = ',\n    sep           = ',',\n    inline_spacer = ' ',\n    show_indices  = false,\n    comparator    = compare,\n1    inline_size   = math.huge\n}\n\noptions.classic = table_clone(options.pretty)\noptions.classic.array_begin     = '{'\noptions.classic.array_end       = '}'\n2options.classic.inline_size     = 0\n\n1\n\nA simple table will be inlined if it has no sub-tables and strictly fewer than inline_size elements.\n\n2\n\nIn the classic format, we never inline simple tables.\n\n\nSo, by default, simple tables are always inlined in the pretty format and never in the classic format. If you set inline_size to 6 in the pretty format, we inline simple tables if they have fewer than six elements.\nGiven our current setup, it only takes a small tweak to our existing code to accommodate this new feature:\nfunction table_string(tbl, opts)\n    opts = opts or options.pretty\n\n1    local md = metadata(tbl)\n2    local size   = md.size\n    local array  = md.array\n3    local simple = md.subs == 0 and md.size &lt;  options.inline_size\n\n    if size == 0 then return empty_table_string(opts) end\n    local show_keys = not array and true or opts.show_indices\n\n    local tb     = array and opts.array_begin or opts.table_begin\n    local te     = array and opts.array_end or opts.table_end\n    local kb, ke = opts.key_begin, opts.key_end\n    local sep    = opts.sep\n4    local indent = simple and '' or opts.indent\n    local nl     = indent == '' and opts.inline_spacer or '\\n'\n    local delims = tb ~= ''\n\n    sep = sep .. nl\n    if delims then tb, te = tb .. nl, nl .. te  else indent = '' end\n\n    local content = ''\n    local i = 0\n    local iter = array and ipairs or ordered_pairs(opts.comparator)\n    for k, v in iter(tbl) do\n        i = i + 1\n        local k_string = show_keys and kb .. tostring(k) .. ke or ''\n        local v_string = ''\n        if type(v) == 'table' then\n            v_string = table_string(v, opts)\n            v_string = indent_string(v_string, opts.indent, delims)\n            if delims == false and show_keys then v_string = nl .. v_string end\n        else\n            v_string = simple_string(v)\n        end\n        content = content .. indent .. k_string .. v_string\n        if i &lt; size then content = content .. sep end\n    end\n    return tb .. content .. te\nend\n\n1\n\nmetadata returns a table instead of a couple of values.\n\n2\n\nExtract the size and array values from the md table.\n\n3\n\nIf there are no sub-tables and the table is small enough, we consider it simple.\n\n4\n\nThis is the only change needed to incorporate that new metadata about tbl.\n\n\nLooking at print(pretty(user)) we get:\n{\n    first = \"Minnie\",\n1    friends = [ \"Mickey\", \"Goofy\" ],\n    last = \"Mouse\"\n}\n\n1\n\nNow, the friends array is printed inline as it has no sub-tables.\n\n\nA more interesting example is:\nlocal matrix = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} }\nThe print(classic(matrix)) gives:\n{\n    {\n        1,\n        2,\n        3\n    },\n    {\n        4,\n        5,\n        6\n    },\n    {\n        7,\n        8,\n        9\n    }\n}\nWith our tweaks print(pretty(matrix)) yields a much more readable:\n[\n    [ 1, 2, 3 ],\n    [ 4, 5, 6 ],\n    [ 7, 8, 9 ]\n]\nAnd print(alt(matrix)) yields\n    1, 2, 3,\n    4, 5, 6,\n    7, 8, 9",
    "crumbs": [
      "Home",
      "Turning the Tables ..."
    ]
  },
  {
    "objectID": "pages/tutorial/index.html#table-metadata",
    "href": "pages/tutorial/index.html#table-metadata",
    "title": "Tutorial: Turning the Tables …",
    "section": "Table Metadata",
    "text": "Table Metadata\nOur current scheme computes each table’s metadata on the fly. When we start our process with the root table, or when we recurse into a sub-table, we have the call to compute the metadata for the table that is currently under the microscope:\nfunction table_string(tbl, opts)\n    opts = opts or options.pretty\n\n1    local md = metadata(tbl)\n    local size   = md.size\n    ...\n\n1\n\nThe current table of interest is tbl.  md(tbl) returns a metadata table for tbl.\n\n\nHowever, tables can reference other tables and even have references to themselves. For example, we might build a website with Disney characters and have a gallery where visitors can flip from one star to the next and back to the previous one, etc.\nA doubly linked list is one data structure to model this type of interaction. In the most dumbed down, minimal version, we might have:\nlocal stars =\n{\n    c1 = { first = \"Mickey\", last = \"Mouse\" },\n    c2 = { first = \"Minnie\", last = \"Mouse\" }\n}\nstars.c1.next = stars.c2\nstars.c2.prev = stars.c1\nstars.home = stars\nHere, c1, c2, … are characters. Each has a table of associated data (more realistically, a table of image links and the like).\nThe characters are connected by their next and previous links. To cap it all, we have a “home” link back to the original table — a self-reference.\nIf you try print(pretty(stars)) with our current implementation, the program will chase its tail and die of pure embarrassment at the rubbish state of table_string.\nBefore we get to that, we will first alter our metadata function significantly.\nInstead of treating each table as it comes along and passing back some associated metadata, we will view the table as a whole entity in one go.\nOur current metadata(tbl) returns md, a table with three fields, size, array and simple, that tell you something about tbl.\nIn our new implementation, metadata(tbl) will return md as a table of tables. If t is tbl itself or any sub-table of tbl, then\n\n\n\n\n\n\n\nField\nDescription\n\n\n\n\nmd[t].size\nThe number of top-level elements in t.\n\n\nmd[t].array\nThis will be true if t is a Lua array, otherwise false.\n\n\nmd[t].subs\nThe number of sub-tables in t.\n\n\n\nHere is what our new call-it-once-and-be-done metadata function looks like:\n1local function metadata(tbl, md)\n2    md = md or {}\n3    md[tbl] = {}\n    local size, array, subs = 0, true, 0\n    for _, v in pairs(tbl) do\n        size = size + 1\n        if array and tbl[size] == nil then array = false end\n        if type(v) == 'table' then\n            subs = subs + 1\n4            if not md[v] then metadata(v, md) end\n        end\n    end\n5    md[tbl].size  = size\n    md[tbl].array = array\n    md[tbl].subs  = subs\n    return md\nend\n\n1\n\nWe’ve added md to the calling signature. It will be missing on the first call.\n\n2\n\nIf md is completely missing, we set it up as an empty table.\n\n3\n\nWe set up md[tbl] as an empty sub-table of md.\n\n4\n\nAs we iterate through tbl, we may come across a new sub-table v, which is handled by recursion.\n\n5\n\nRecord the three bits of metadata for tbl in the md[tbl] sub-table.\n\n\nTo use this new metadata method, we also need to alter table_string. That can be done a couple of different ways. One way to go is to make table_string a little wrapper around a recursive closure that does most of the work:\n1function table_string(root_tbl, opts)\n    opts = opts or options.pretty\n2    local md = metadata(root_tbl)\n\n3    local function process(tbl)\n4        local size   = md[tbl].size\n        if size == 0 then return empty_table_string(opts) end\n\n        local array  = md[tbl].array\n        local show_keys = not array and true or opts.show_indices\n\n        local simple = md[tbl].subs == 0 and size &lt; opts.inline_size\n        local indent = simple and '' or opts.indent\n\n        local tb     = array and opts.array_begin or opts.table_begin\n        local te     = array and opts.array_end or opts.table_end\n        local kb, ke = opts.key_begin, opts.key_end\n        local nl     = indent == '' and opts.inline_spacer or '\\n'\n        local sep    = opts.sep .. nl\n\n        local delims = tb ~= ''\n        if delims then tb, te = tb .. nl, nl .. te  else indent = '' end\n\n        local content = ''\n        local i = 0\n        local iter = array and ipairs or ordered_pairs(opts.comparator)\n        for k, v in iter(tbl) do\n            i = i + 1\n            local k_string = show_keys and kb .. tostring(k) .. ke or ''\n            local v_string = ''\n            if type(v) == 'table' then\n5                v_string = process(v)\n                v_string = indent_string(v_string, opts.indent, delims)\n                if delims == false and show_keys then v_string = nl .. v_string end\n            else\n                v_string = simple_string(v)\n            end\n            content = content .. indent .. k_string .. v_string\n            if i &lt; size then content = content .. sep end\n        end\n        return tb .. content .. te\n    end\n\n6    local retval = process(root_tbl)\n    return retval\nend\n\n1\n\nNow, table_string is primarily a wrapper around the inner process function.  We have changed the first argument to root_tbl to clarify that this is the root table.\n\n2\n\nWe compute the root table root_tbl metadata and store it in md.\n\n3\n\nThe process function is a closure and can access the enclosed md table.\n\n4\n\nmd[tbl] is a sub-table, currently with three fields, size, array and simple.\n\n5\n\nIf we hit a sub-table, we recurse using process. The md table does not need recomputing and continues to be available as we process v.\n\n6\n\nMost of the source lines in table_string are in the private process sub-function. We have md and get the ball rolling by running process on root_tbl.",
    "crumbs": [
      "Home",
      "Turning the Tables ..."
    ]
  },
  {
    "objectID": "pages/tutorial/index.html#cyclical-references",
    "href": "pages/tutorial/index.html#cyclical-references",
    "title": "Tutorial: Turning the Tables …",
    "section": "Cyclical References",
    "text": "Cyclical References\nIf we look at a simple linked list example:\nlocal stars =\n{\n    c1 = { first = \"Mickey\", last = \"Mouse\"},\n    c2 = { first = \"Minnie\", last = \"Mouse\"},\n}\nstars.c1.next = stars.c2\nThen print(pretty(stars)) returns:\n{\n    c1 =\n    {\n        next = {\n            first = Minnie,\n            last = Mouse\n        },\n        first = Mickey,\n        last = Mouse\n    },\n    c2 = {\n        first = Minnie,\n        last = Mouse\n    }\n}\nWe see two definitions of c2!  One is in the next field for c1 and another when we get to c2 by itself. That’s not ideal.\nThings get worse if we use a doubly linked list by adding:\nstars.c2.prev = stars.c1\nNow, when we try print(pretty(stars)) the program will crash with a message like\n1/path/to/script: stack overflow\nstack traceback:\n /path/to/script:49: in function 'table_size_and_type'\n /path/to/script:98: in function 'table_string'\n /path/to/script: in function 'table_string'\n /path/to/script: in function 'table_string'\n /path/to/script: in function 'table_string'\n /path/to/script: in function 'table_string'\n /path/to/script: in function 'table_string'\n /path/to/script: in function 'table_string'\n /path/to/script: in function 'table_string'\n /path/to/script: in function 'table_string'\n2 ... (skipping 58803 levels)\n /path/to/script: in function 'table_string'\n /path/to/script: in function 'table_string'\n /path/to/script: in function 'table_string'\n /path/to/script: in function 'table_string'\n /path/to/script: in function 'table_string'\n /path/to/script: in function 'table_string'\n /path/to/script: in function 'table_string'\n /path/to/script: in function 'table_string'\n /path/to/script: in function 'table_string'\n3 (...tail calls...)\n\n1\n\nLua’s interpreter has run out of room.\n\n2\n\nThat’s a lot of skipping!\n\n3\n\nIt’s more like tail chasing in this instance!\n\n\nIt is easy to see what the issue is. When we convert c1 to a string, it encounters a sub-table c2. Our function then calls itself with a request to convert c2 to a string. That call, in its turn, will encounter c2.prev = c1 and see that c1 is a table. It handles that by calling itself with a request to convert c1 to a string. And round and round we go!\nOur current solution doesn’t handle tables with shared references well. Even if it manages to complete, the shared table will be defined multiple times. The situation is even worse if there are cycles to be navigated. Those cause the program to crash with a stack overflow,\nLua makes it very easy to have tables with multiple references and cycles. Under the covers, the assignment c2.prev = c1 sets up another pointer to c1. No copying is done; everything is very efficient.\nThat’s great for many algorithms you might use beyond the most straightforward, plain old data tables. We still need to examine and view those tables without crashes.\n\nCrash Proofing\nThe key to handling tables with cycles and shared references is marking those tables we have already put out a full string definition for. If we see those marked tables again, we can do something more sensible than trying to define them again and potentially going around in circles.\nOur metadata function returns a metadata table for each table and sub-table it encounters. Currently, there are just three fields in that metadata table: size, array, and simple. We can add a fourth field, processed, that will be true if we have already seen and processed that table. If the processed field is true, we can print a simple reference to the table instead of trying to define it again. If the field is missing, we can define the table as we do now.\nHere is what the table_string function looks like with the processed field added:\nfunction table_string(root_tbl, opts)\n    opts = opts or options.pretty\n    local md = metadata(tbl)\n\n    local function process(tbl)\n1        md[tbl].processed = true\n        ...\n        for k, v in iter(tbl) do\n            i = i + 1\n            local k_string = show_keys and kb .. tostring(k) .. ke or ''\n            local v_string = ''\n            if type(v) == 'table' then\n                if md[v].processed then\n2                    v_string = simple_string(v)\n                else\n3                    v_string = process(v)\n                    v_string = indent_string(v_string, opts.indent, delims)\n                    if delims == false and show_keys then v_string = nl .. v_string end\n                end\n            ...\n        end\n        return tb .. content .. te\n    end\n\n    local retval = process(root_tbl)\n    return retval\nend\n\n1\n\nWe are about to process tbl, so we mark it as processed in case it has a self-reference.\n\n2\n\nWe have seen v before and can do something else instead of recursing.  Here, we print a reference to the table’s address.\n\n3\n\nRecurse into v and build up a complete definition for it.\n\n\nNow, if you try print(pretty(stars)) on our doubly linked list of stars, you get something like this:\n{\n    c1 = {\n        first = \"Mickey\",\n        last = \"Mouse\",\n        next = {\n            first = \"Minnie\",\n            last = \"Mouse\",\n            prev = 0x600002ec0ec0\n        }\n    },\n    c2 = 0x600002ec0f00,\n}\n\nThe shared references are just table addresses, which isn’t user-friendly but better than crashing!\n\nWe can even add a self-reference to the stars table like this:\nstars.home = stars\nThen print(pretty(stars)) yields:\n{\n    c1 = {\n        first = \"Mickey\",\n        last = \"Mouse\",\n        next = {\n            first = \"Minnie\",\n            last = \"Mouse\",\n            prev = 0x6000012ecec0\n        }\n    },\n    c2 = 0x6000012ecf00,\n    home = 0x6000012ece80\n}\n\n\nPaths\nThat output is not very user-friendly.\nHow should we see those references? Ideally, we should see an understandable description of the reference.\nEvery table has a unique address in Lua, which we could use. However, as we saw above, that’s not very user-friendly. We could use the key in the table that points to the shared table. That is better, but still not great. We could use a path to the table from the top-level root table. This is the best option.\nThen, in the case where there is no self-reference, we might see:\n{\n    c2 = {\n        first = Minnie,\n        prev = {\n            first = Mickey,\n1            next = &lt;c1&gt;,\n            last = Mouse\n        },\n        last = Mouse\n    },\n2    c1 = &lt;c2.prev&gt;\n}\n\n1\n\nThe value of next refers to the table at the path c1.\n\n2\n\nThe value of c1 refers to the table at the path c2.prev.\n\n\nIf the root table is tbl, then the path \"&lt;foo.bar.baz&gt;\" refers to the value tbl.foo.bar.baz. Thus, foo is a sub-table of tbl, bar is a sub-table of foo, and baz is a value in bar.\nIf there is a self-reference, such as stars.home = stars, we might see:\n1&lt;table&gt; = {\n    c2 = {\n        first = Minnie,\n        prev = {\n            first = Mickey,\n2            next = &lt;c1&gt;,\n            last = Mouse\n        },\n        last = Mouse\n    },\n    c1 = &lt;c2.prev&gt;,\n3    home = &lt;table&gt;\n}\n\n1\n\nWe only put out the &lt;table&gt; = ... line if there is a self-reference.\n\n2\n\nWe could use the full path, &lt;table.c1&gt;, here, but that is generally overkill.\n\n3\n\nThe value of home refers to the table itself.\n\n\nIn this representation, there are some obvious user-settable options: - The string used for the root table if there are any top-level self-references. In the example, we use table for that. - The separator to use in the path string to sub-sub-tables etc. In the example, we use\".\". - Perhaps the delimiters to use for path strings, which in the example are &lt; and &gt;.\nLet’s add those to our options.pretty table:\nlocal options = {}\noptions.pretty = {\n    indent        = '    ',\n    table_begin   = '{',\n    table_end     = '}',\n    array_begin   = '[',\n    array_end     = ']',\n    key_begin     = '',\n    key_end       = ' = ',\n    sep           = ',',\n    inline_spacer = ' ',\n    show_indices  = false,\n    comparator    = compare,\n    inline_size   = math.huge,\n1    path_root     = 'table',\n2    path_sep      = '.',\n3    path_begin    = '&lt;',\n    path_end      = '&gt;'\n}\n\n1\n\nThe string for the root table if there are any top-level self-references.\n\n2\n\nThe separator used in the path string to sub-sub-tables, etc.\n\n3\n\nThe delimiters used for the path string.\n\n\nWith that in place, we can modify the table_string function as follows:\nfunction table_string(root_tbl, opts)\n    opts = opts or options.pretty\n    local md = metadata(root_tbl)\n\n1    local function process(tbl, path)\n2        md[tbl].path = path\n\n        local size   = md[tbl].size\n        if size == 0 then return empty_table_string(opts) end\n\n        local array  = md[tbl].array\n        local show_keys = not array and true or opts.show_indices\n\n        local simple = md[tbl].subs == 0 and size &lt; opts.inline_size\n        local indent = simple and '' or opts.indent\n\n        local tb     = array and opts.array_begin or opts.table_begin\n        local te     = array and opts.array_end or opts.table_end\n        local kb, ke = opts.key_begin, opts.key_end\n3        local pb, pe = opts.path_begin, opts.path_end\n        local nl     = indent == '' and opts.inline_spacer or '\\n'\n        local sep    = opts.sep .. nl\n\n        local delims = tb ~= ''\n        if delims then tb, te = tb .. nl, nl .. te  else indent = '' end\n\n        local content = ''\n        local i = 0\n        local iter = array and ipairs or ordered_pairs(opts.comparator)\n        for k, v in iter(tbl) do\n            i = i + 1\n            local k_string = show_keys and kb .. tostring(k) .. ke or ''\n            local v_string = ''\n            if type(v) == 'table' then\n                if md[v].path then\n4                    v_string = pb .. md[v].path .. pe\n                else\n5                    local v_path = path .. opts.path_sep .. tostring(k)\n                    v_string = process(v, v_path)\n6                    v_string = indent_string(v_string, opts.indent, delims)\n                    if delims == false and show_keys then v_string = nl .. v_string end\n                end\n            else\n                v_string = simple_string(v)\n            end\n            content = content .. indent .. k_string .. v_string\n            if i &lt; size then content = content .. sep end\n        end\n        return tb .. content .. te\n    end\n\n7    local retval = process(root_tbl, opts.path_root)\n    return retval\nend\n\n1\n\nWe have added an extra path argument.\n\n2\n\nWe record the path to this table tbl as the value under the metadata key path in md[tbl].\n\n3\n\nLocalise the path-begin and path-end delimiters.\n\n4\n\nIf we have seen v before, we use the path string we stored in md for v, formatted with the delimiters.\n\n5\n\nv is a new table, so we need a path to v, which we get by appending the key k to the current path.\n\n6\n\nWe recurse processing the contents of v using that new path string.\n\n7\n\nKick off the process with the root table and path.\n\n\nNow, if you try print(pretty(stars)) on our doubly linked list of stars, we get:\n{\n    c1 = {\n        first = Mickey,\n        last = Mouse,\n        next = {\n            first = Minnie,\n            last = Mouse,\n1            prev = &lt;table.c1&gt;\n        }\n    },\n    c2 = &lt;table.c1.next&gt;,\n2    home = &lt;table&gt;\n}\n\n1\n\nThe value of prev refers to the path table.c1.\n\n2\n\nThe value of home refers to the table itself.\n\n\nIn a reference like &lt;table.c1.next&gt;, the root path prefix table. isn’t necessary. We will remove it in the next iteration.\nComplete self-references like our home = &lt;table&gt; line are uncommon, but we would like to have that &lt;table&gt; defined if it does occur. Something along these lines:\n&lt;table&gt; = {\n ...\n}\nHowever, that extra &lt;table&gt; = should only be present if there is a self-reference.\nWe can alter table_string as follows:\nfunction table_string(root_tbl, opts)\n    opts = opts or options.pretty\n    local md = metadata(root_tbl)\n\n1    local root = root_tbl\n2    local root_ref = false\n\n3    local kb, ke = opts.key_begin, opts.key_end\n    local pb, pe = opts.path_begin, opts.path_end\n\n    local function process(tbl, path)\n        md[tbl].path = path\n4        local path_prefix = path == opts.path_root and '' or path .. opts.path_sep\n\n        local size = md[tbl].size\n        if size == 0 then return empty_table_string(opts) end\n\n        local array = md[tbl].array\n        local show_keys = not array and true or opts.show_indices\n\n        local simple = md[tbl].subs == 0 and size &lt; opts.inline_size\n        local indent = simple and '' or opts.indent\n\n        local tb = array and opts.array_begin or opts.table_begin\n        local te = array and opts.array_end or opts.table_end\n        local nl = indent == '' and opts.inline_spacer or '\\n'\n        local sep = opts.sep .. nl\n\n        local delims = tb ~= ''\n        if delims then tb, te = tb .. nl, nl .. te else indent = '' end\n\n        local content = ''\n        local i = 0\n        local iter = array and ipairs or ordered_pairs(opts.comparator)\n        for k, v in iter(tbl) do\n            i = i + 1\n            local k_string = show_keys and kb .. tostring(k) .. ke or ''\n            local v_string = ''\n            if type(v) == 'table' then\n                if md[v].path then\n                    v_string = pb .. md[v].path .. pe\n5                    if v == root then root_ref = true end\n                else\n6                    local v_path = path_prefix .. tostring(k)\n                    v_string = process(v, v_path)\n                    v_string = indent_string(v_string, opts.indent, delims)\n                    if delims == false and show_keys then v_string = nl .. v_string end\n                end\n            else\n                v_string = simple_string(v)\n            end\n            content = content .. indent .. k_string .. v_string\n            if i &lt; size then content = content .. sep end\n        end\n        return tb .. content .. te\n    end\n\n    local retval = process(root_tbl, opts.path_root)\n7    if root_ref then\n        retval = pb .. opts.path_root .. pe .. ' = ' .. retval\n    end\n    return retval\nend\n\n1\n\nWe capture the root table in root.\n\n2\n\nWe capture whether there is a self-reference to the root table in root_ref.\n\n3\n\nLocalise some delimiters that never vary by context (hoist these constant lines from the process function).\n\n4\n\nIf this is not the root table, we will prepend any new path with a path prefix.\n\n5\n\nWe record the self-reference to the root table if v is the root table.\n\n6\n\nWe prepend the path with the path prefix if tbl is not the root table.\n\n7\n\nIf there is a self-reference to the root table, we prepend the return string with &lt;table&gt; =.\n\n\nHere’s the output from the latest version of print(pretty(stars)):\n1&lt;table&gt; = {\n    c1 = {\n        first = Mickey,\n        last = Mouse,\n        next = {\n            first = Minnie,\n            last = Mouse,\n            prev = &lt;c1&gt;\n        }\n    },\n2    c2 = &lt;c1.next&gt;,\n3    home = &lt;table&gt;\n}\n\n1\n\nThere is a self-reference to the stars parent table, so we have prepended the string with &lt;table&gt; =.\n\n2\n\nThis looks better than &lt;table.c1.next&gt;.\n\n3\n\nHere is the self-reference to the root table, which reads quite naturally.\n\n\nIf we remove the stars.home = stars assignment then print(pretty(stars)) returns:\n1{\n    c1 = {\n        next = {\n            first = Minnie,\n            prev = &lt;c1&gt;,\n            last = Mouse\n        },\n        first = Mickey,\n        last = Mouse\n    },\n    c2 = &lt;c1.next&gt;\n}\n\n1\n\nThere is no self-reference, so we do not need that &lt;table&gt; = we saw earlier.",
    "crumbs": [
      "Home",
      "Turning the Tables ..."
    ]
  },
  {
    "objectID": "pages/tutorial/index.html#breadth-first-traversal",
    "href": "pages/tutorial/index.html#breadth-first-traversal",
    "title": "Tutorial: Turning the Tables …",
    "section": "Breadth First Traversal",
    "text": "Breadth First Traversal\nWhile that last output is undoubtedly valid, it fails the readability test.\nThat c2 = &lt;c1.next&gt; is perfectly correct, but you have to go back and find the definition of c1 to understand what c1.next actually is. It would be much better to see the definition of c2 right there, not nested inside c1. We are after something that looks like this:\n{\n c1 =\n {\n first = Minnie,\n last = Mouse,\n next = &lt;c2&gt;\n },\n c2 =\n {\n first = Mickey,\n last = Mouse,\n prev = &lt;c1&gt;\n },\n home = &lt;table&gt;\n}\n\nWe would like to see the full definition of tables at the shallowest possible depth.\n\nThe root problem is that we are traversing tables depth-first.\nWe process all the elements in c1 before getting to c2. So when we see c1.next, we print the full definition of what c2 really is. Then, later, when we get to c2, we see that we have already processed it and output it as a reference to &lt;c1.next&gt;. That is ass-backwards and c1.next should be the reference to &lt;c2&gt;, and the definition of c2 should be deferred to later.\n\n    \n     \n    \n    \nAll the table-to-string implementations that are available on the web seem to have this problem, The depth-first traversal is a natural choice, but it doesn’t provide the most readable output.\n\nWe need to change the table traversal to be breadth-first. Then, we process the elements of tbl in the order they appear at the top level. If we encounter a sub-table, we will defer turning it to a string until after processing all the top-level elements.\nTo demonstrate, let’s see how breadth first traversal works for the simpler metadata method:\nlocal function metadata(tbl, md)\n    md = md or {}\n    md[tbl] = {}\n    local size, array, subs = 0, true, 0\n1    local children = {}\n    for _, v in pairs(tbl) do\n        size = size + 1\n        if array and tbl[size] == nil then array = false end\n        if type(v) == 'table' then\n            subs = subs + 1\n2            if not md[v] then table.insert(children, v) end\n        end\n    end\n    md[tbl].size, md[tbl].array, md[tbl].subs = size, array, subs\n\n3    for _, child in ipairs(children) do metadata(child, md) end\n    return md\nend\n\n1\n\nWe keep a list of the sub-tables we encounter.\n\n2\n\nIf we encounter a sub-table, we add it to the list of children and defer immediate processing.\n\n3\n\nAfter processing all the top-level elements, we then process the children.\n\n\nChanging the processing order in metadata doesn’t change the output. print(pretty(metadata(stars))) still gives:\n&lt;table&gt; = {\n c1 = {\n first = \"Mickey\",\n last = \"Mouse\",\n next = {\n first = \"Minnie\",\n last = \"Mouse\",\n prev = &lt;c1&gt;\n }\n },\n c2 = &lt;c1.next&gt;,\n home = &lt;table&gt;\n}\nWe need to apply similar changes to the more complex table_string function:\nfunction table_string(root_tbl, opts)\n    ...\n    local function process(tbl, path)\n        ...\n        local children = {}\n        ...\n        for k, v in iter(tbl) do\n            ...\n            if type(v) == 'table' then\n                if md[v].path then\n                    v_string = pb .. md[v].path .. pe\n                    if v == root then root_ref = true end\n                else\n                    local v_path = path_prefix .. tostring(k)\n                    v_string = simple_string(v)\n                    md[v].path = v_path\n                    children[v] = v_path\n                    if delims == false and show_keys then v_string = nl .. v_string end\n                end\n            else\n                v_string = v_string .. simple_string(v)\n            end\n            content = content .. indent .. k_string .. v_string\n            if i &lt; size then content = content .. sep end\n        end\n        local retval = tb .. content .. te\n\n        for child_table, child_path in pairs(children) do\n            local child_string = process(child_table, child_path)\n            child_string = indent_string(child_string, opts.indent, delims)\n            retval = retval:gsub(simple_string(child_table), child_string)\n        end\n        return retval\n    end\n\n    local retval = process(root_tbl, opts.path_root)\n    if root_ref then retval = pb .. opts.path_root .. pe .. ' = ' .. retval end\n    return retval\nend\nWith that change, print(pretty(stars)) now gives:\n&lt;table&gt; = {\n c1 = {\n first = \"Mickey\",\n last = \"Mouse\",\n next = &lt;c2&gt;\n },\n c2 = {\n first = \"Minnie\",\n last = \"Mouse\",\n prev = &lt;c1&gt;\n },\n home = &lt;table&gt;\n}\n\nArrays\nThat last table is very readable. Every shared reference like c1.next = &lt;c2&gt; has an easily identifiable right-hand side value, the value associated with the key c2 in this case.\nHowever, we have gone to some lengths to suppress showing explicit keys for Lua tables that happen to be arrays. If we have an array of arrays with shared references, the paths will lack clarity.\nFor example, perhaps you are coding a Cludeo-type murder mystery game set in a big house with many rooms stored as an array. Each room might have a potential murder weapon in it:\nlocal rooms = {\n    { name = \"Library\", weapon = \"Lead Pipe\" },\n    { name = \"Kitchen\", weapon = \"Knife\"     },\n    { name = \"Lounge\",  weapon = \"Poison\"    },\n    { name = \"Bedroom\", weapon = \"Garrotte\"  }\n}\nThe user will move from room to room in a fashion that might be randomly generated or set by the game’s storyline. To keep it simple, we add next and prev fields to each room as follows:\nrooms[1].next, rooms[2].next, rooms[3].next, rooms[4].next = rooms[2], rooms[3], rooms[4], rooms[1]\nrooms[1].prev, rooms[2].prev, rooms[3].prev, rooms[4].prev = rooms[4], rooms[1], rooms[2], rooms[3]\nNow if we print(pretty(rooms)) we get:\n[\n    {\n        name = \"Library\",\n        next = &lt;2&gt;,\n        prev = &lt;4&gt;,\n        weapon = \"Lead Pipe\"\n    },\n    {\n        name = \"Kitchen\",\n        next = &lt;3&gt;,\n        prev = &lt;1&gt;,\n        weapon = \"Knife\"\n    },\n    {\n        name = \"Lounge\",\n        next = &lt;4&gt;,\n        prev = &lt;2&gt;,\n        weapon = \"Poison\"\n    },\n    {\n        name = \"Bedroom\",\n        next = &lt;1&gt;,\n        prev = &lt;3&gt;,\n        weapon = \"Garrotte\"\n    }\n]\nrooms is an array printed without showing the indices. The problem is that path references like next = &lt;1&gt; don’t make much sense.\n\nIf the value associated with an index is shared, we want to see that index explicitly.\n\nThe current implementation makes this difficult. The main loop in table_string looks like this:\n    ...\n        for k, v in iter(tbl) do\n            i = i + 1\n            local k_string = show_keys and kb .. tostring(k) .. ke or ''\n            local v_string = ''\n            if type(v) == 'table' then\n\n            local k_string = show_keys and kb .. tostring(k) .. ke or ''\n    ...\nWe are creating the key string k_string before we know whether the associate value v is a table, let alone a shared table. We also put out the key-value pair at one depth, but any shared reference may be at a different depth.\nThe solution is two-fold. First, add a new metadata field, refs, for each table and sub-table. md[t].refs will be the number of references seen for the table t. If md[t].refs is greater than 1, then t is a shared table.\nWe can compute the reference count field using the metadata method. We also switch the style of the function to having an inner hidden process closure that does all the work. Tables are still getting traversed depth-first.\nlocal function metadata(root_tbl)\n1    local md = {}\n2    md[root_tbl] = { refs = 1 }\n\n3    local function process(tbl)\n        local size, array, subs  = 0, true, 0\n        local children = {}\n        for _, v in pairs(tbl) do\n            size = size + 1\n            if array and tbl[size] == nil then array = false end\n            if type(v) == 'table' then\n                subs = subs + 1\n                if md[v] then\n4                    md[v].refs = md[v].refs + 1\n                else\n5                    table.insert(children, v)\n6                    md[v] = { refs = 1 }\n                end\n            end\n        end\n        md[tbl].size, md[tbl].array, md[tbl].subs = size, array, subs\n7        for _, child in ipairs(children) do process(child) end\n    end\n\n8    process(root_tbl)\n    return md\nend\n\n1\n\nWe set up the metadata table that will be accessible inside the process closure.\n\n2\n\nWe immediately add an entry for the root table as it might be referenced by its immediate children\n\n3\n\nprocess is the recursive function that does all the heavy lifting.\n\n4\n\nIf we’ve seen v before, we increment its reference count.\n\n5\n\nOtherwise we add v to the list of sub-tables to process later.\n\n6\n\nWe add a metadata entry for v here in case it is referenced by an immediate sibling.\n\n7\n\nGo ahead and process the granchildren etc.\n\n8\n\nWe kick things off by processing the root table.\n\n\nOf course, we must tweak our table_string method:\nfunction table_string(root_tbl, opts)\n    ...\n    local function process(tbl, path)\n        ...\n        for k, v in iter(tbl) do\n            i = i + 1\n1            local show_key = show_keys\n            local v_string = ''\n            if type(v) == 'table' then\n                if md[v].path then\n                    v_string = pb .. md[v].path .. pe\n                    if v == root then root_ref = true end\n                else\n2                    if md[v].refs &gt; 1 then show_key = true end\n                    local v_path = path_prefix .. tostring(k)\n                    v_string = simple_string(v)\n                    md[v].path = v_path\n                    children[v] = v_path\n                    if delims == false and show_key then v_string = nl .. v_string end\n                end\n            else\n                v_string = v_string .. simple_string(v)\n            end\n3            local k_string = show_key and kb .. tostring(k) .. ke or ''\n            content = content .. indent .. k_string .. v_string\n            if i &lt; size then content = content .. sep end\n        end\n        ...\n    end\n    ...\nend\n\n1\n\nBy default we show this key based on the value of show_keys.\n\n2\n\nIf v is new and has a reference count greater than 1, we will show the corresponding key whether or not show_keys is false. We must do that so that any path references to v make sense.\n\n3\n\nNow that we know the state of play, we can finally set the string for this key.\n\n\nWith this change, print(pretty(rooms)) gives:\n[\n    1 = {\n        name = \"Library\",\n1        next = &lt;2&gt;,\n        prev = &lt;4&gt;,\n        weapon = \"Lead Pipe\"\n    },\n    2 = {\n        name = \"Kitchen\",\n        next = &lt;3&gt;,\n        prev = &lt;1&gt;,\n        weapon = \"Knife\"\n    },\n    3 = {\n        name = \"Lounge\",\n        next = &lt;4&gt;,\n        prev = &lt;2&gt;,\n        weapon = \"Poison\"\n    },\n    4 = {\n        name = \"Bedroom\",\n        next = &lt;1&gt;,\n        prev = &lt;3&gt;,\n        weapon = \"Garrotte\"\n    }\n]\n\n1\n\nThe path reference &lt;2&gt; now makes perfect sense.\n\n\nHere’s what we get for print(alt(rooms)):\n1:\n    name: \"Library\",\n    next: &lt;2&gt;,\n    prev: &lt;4&gt;,\n    weapon: \"Lead Pipe\",\n2:\n    name: \"Kitchen\",\n    next: &lt;3&gt;,\n    prev: &lt;1&gt;,\n    weapon: \"Knife\",\n3:\n    name: \"Lounge\",\n    next: &lt;4&gt;,\n    prev: &lt;2&gt;,\n    weapon: \"Poison\",\n4:\n    name: \"Bedroom\",\n    next: &lt;1&gt;,\n    prev: &lt;3&gt;,\n    weapon: \"Garrotte\"\nThis output is also very readable.\n\n\nOne Small Tweak\nOur current definition of a “simple” table is one that has no sub-tables. But what is a sub-table?\nWe can very slightly alter our metadata function to not count path references as distinct sub-tables.\nlocal function metadata(root_tbl)\n    ...\n    local function process(tbl)\n        ...\n        for _, v in pairs(tbl) do\n            ...\n            if type(v) == 'table' then\n1                -- subs = subs + 1\n                if md[v] then\n                    md[v].refs = md[v].refs + 1\n                else\n2                    subs = subs + 1\n                    table.insert(children, v)\n                    md[v] = { refs = 1 }\n                end\n            end\n        end\n        ...\n    end\nend\n\n1\n\nWe move this line\n\n2\n\nto here.\n\n\nWith that change only “real” sub-tables count towards the sub total.\nprint(pretty(rooms)) now gives the more compact but still readable:\n[\n    1 = { name = \"Library\", next = &lt;2&gt;, prev = &lt;4&gt;, weapon = \"Lead Pipe\" },\n    2 = { name = \"Kitchen\", next = &lt;3&gt;, prev = &lt;1&gt;, weapon = \"Knife\" },\n    3 = { name = \"Lounge\", next = &lt;4&gt;, prev = &lt;2&gt;, weapon = \"Poison\" },\n    4 = { name = \"Bedroom\", next = &lt;1&gt;, prev = &lt;3&gt;, weapon = \"Garrotte\" }\n]",
    "crumbs": [
      "Home",
      "Turning the Tables ..."
    ]
  },
  {
    "objectID": "pages/tutorial/index.html#scribe-facade",
    "href": "pages/tutorial/index.html#scribe-facade",
    "title": "Tutorial: Turning the Tables …",
    "section": "Scribe Facade",
    "text": "Scribe Facade\n\nIntroduction\nAfter the first attempt at table_string(tbl), we commented that, while the method name was descriptive, we needed to check that the tbl argument is an actual table.\nInstead of doing that, we will create another “facade” function scribe that will return a string for any Lua object. The user will call this function, and we will make table_string a private function only called by scribe when the object is a table. Currently, our table_string function starts as follows:\n1function table_string(root_tbl, opts)\n2    opts = opts or options.pretty\n    local md = metadata(root_tbl)\n    ...\nend\n\n1\n\ntable_string is a global function that is available to the user.\n\n2\n\nIt has to check if opts is provided; if not, set it to the default options.pretty.\n\n\nWe will change this to:\n1local function table_string(root_tbl, opts)\n2    local md = metadata(root_tbl)\n    ...\nend\n\n1\n\nWe make table_string a local function.\n\n2\n\nWe remove the opts check as we know that scribe will always provide it.\n\n\n\n    \n     \n    \n    \nIn a later chapter, we will discuss the difference between global and local functions.\n\nIn the meantime, we introduce scribe as follows:\n1function scribe(obj, opts)\n2    if type(obj) ~= 'table' then return simple_string(obj) end\n3    opts = opts or options.pretty\n4    return table_string(obj, opts)\nend\n\n1\n\nobj can be any Lua object and opts is an optional table of opts.\n\n2\n\nWe handle non-table objects up-front by calling simple_string.\n\n3\n\nWe set the opts to the default options.pretty if it is not provided.\n\n4\n\nIf we get here, we know that obj is a table, so we call the private table_string method to convert it to a string.\n\n\nOf course, our other public facade functions will also call scribe instead of table_string directly. For example, pretty_string will now look like this:\nfunction pretty_string(tbl, opts)\n1    return scribe(tbl, options.pretty)\nend\n\n1\n\nWe call scribe with the options.pretty table.\n\n\n\n\nHealth and Safety\nWe have now added a layer of protection to our table_string function by ensuring that it is only called by scribe when the object is a table.\nHowever, we still need to check that the opts table is complete. Each of those many fields in the options table must be present, or table_string will fail.\nOf course, we are sure that the standard options tables we provide are complete, but what if the user provides their own options table?\nWe start by adding a “marker” to our own options tables to indicate that they are complete:\nlocal options = {}\noptions.pretty = {\n    indent        = '    ',\n    table_begin   = '{',\n    table_end     = '}',\n    array_begin   = '[',\n    array_end     = ']',\n    key_begin     = '',\n    key_end       = ' = ',\n    sep           = ',',\n    inline_spacer = ' ',\n    show_indices  = false,\n    comparator    = compare,\n    inline_size   = math.huge,\n    path_root     = 'table',\n    path_sep      = '.',\n    path_begin    = '&lt;',\n    path_end      = '&gt;',\n1    COMPLETE      = true\n}\n\n1\n\nIf the user provides their own options table, we will check for the presence of this field to determine if it is complete.\n\n\nWe also add a function that adds missing fields to an options table:\n1local function complete_options_table(options, from)\n    for k, v in pairs(from) do\n2        if options[k] == nil then options[k] = v end\n    end\nend\n\n1\n\nThis function takes two arguments: the opts table to complete and the from table to use as a template.\n\n2\n\nWe add missing fields from the from table to the opts table.\n\n\ncomplete_options_table is a private function that is only called by scribe, so we are sure that edge cases are handled correctly. For example, we can be confident that there will be two arguments and that the second argument will be a complete options table.\nWe call this function scribe:\nfunction scribe(obj, opts)\n    if type(obj) ~= 'table' then return simple_string(obj) end\n1    opts = opts or options.pretty\n2    if not opts.COMPLETE then\n3        local from = opts.indent == '' and options.inline or options.pretty\n4        complete_options_table(options, from)\n    end\n5    return table_string(obj, opts)\nend\n\n1\n\nIf the user does not provide any options table, we use the options.pretty table.\n\n2\n\nIf the user provides a custom options table, we ensure it’s complete before calling table_string.\n\n3\n\nWe use the options.inline table if the indent field is empty. Otherwise, we use the options.pretty table.\n\n4\n\nWe call the complete_options_table function to add any missing fields to the opts table.\n\n5\n\nWe can safely call table_string with the complete opts table.\n\n\nAdding that COMPLETE field to our options tables can avoid most performance issues and ensure that our code is robust.\n\n    \n     \n    \n    \nThere is a caveat to this approach. If the user provides their own incomplete options table, then the first time we see it, we alter it. Generally, changing things under-the-covers is a bad idea, but in this case, the user will only see the performance hit once. All in all, it is a reasonable trade-off.\n\nHere is an example of how the user can provide their own minimal options table that sets the indent to two spaces:\nlocal my_options = { indent = '  ' }\nlocal user =\n{\n    first = \"Minnie\",\n    last = \"Mouse\",\n    friends = { \"Mickey\", \"Goofy\" }\n}\nprint(scribe(user, my_options))\nThis will output:\n{\n first = \"Minnie\",\n last = \"Mouse\",\n friends = { \"Mickey\", \"Goofy\" }\n}\nThe my_options table is complete as far as table_string is concerned. We can inspect it by a call to print(classic(my_options)) which will output:\n{\n1    COMPLETE = true,\n    array_begin = \"[\",\n    array_end = \"]\",\n2    comparator = &lt;function&gt;,\n3    indent = \"  \",\n4    inline_size = inf,\n    inline_spacer = \" \",\n    key_begin = \"\",\n    key_end = \" = \",\n    path_begin = \"&lt;\",\n    path_end = \"&gt;\",\n    path_root = \"table\",\n    path_sep = \".\",\n    sep = \",\",\n    show_indices = false,\n    table_begin = \"{\",\n    table_end = \"}\"\n}\n\n1\n\nThe COMPLETE field is present and set to true,; all the other fields are present and mostly set to the default values from the options.pretty table.\n\n2\n\nThe comparator field is shown as &lt;function&gt;.\n\n3\n\nThe indent field is set to two spaces as provided by the user.\n\n4\n\ninf means infinity, accessible in Lua as math.huge.\n\n\nThe next time we call scribe with the my_options table, it will be complete and we will not have to call complete_options_table again.\n\n\nOverrides\nWe also want to allow the user to override one or more options in any of the pre-canned options tables.\nThe signature of your main scribe function will now look like this:\n1function scribe(obj, options, overrides)\n    ...\nend\n\n1\n\nWe add a third argument, overrides, which is an optional table of options to override.\n\n\nNow, both the second opts argument and the third overrides argument are optional. A moment’s thought will convince you that if the opts argument is missing, the overrides argument is also.\nHere is the full scribe function:\nfunction scribe(obj, options, overrides)\n1    if type(obj) ~= 'table' then return simple_string(obj) end\n\n2    if options == nil then return table_string(obj, options.pretty) end\n\n3    if not opts.COMPLETE then\n        local from = opts.indent == '' and options.inline or options.pretty\n        complete_options_table(options, from)\n    end\n4    if overrides == nil then return table_string(obj, opts) end\n\n    if not overrides.COMPLETE then complete_options_table(overrides, opts) end\n5    return table_string(obj, overrides)\nend\n\n1\n\nAs usual, we handle non-table objects up-front.\n\n2\n\nIf the user does not provide an opts table, we use the options.pretty table and are done.\n\n3\n\nWe complete an incomplete opts table if the user provides it.\n\n4\n\nIf the user does not provide an overrides table, we use the opts table and are done.\n\n5\n\nIf the user provides an overrides table, we complete it from the opts table and use it.  By the time we get here, we can be sure that the opts table is complete.\n\n\nWe also alter the facade functions to permit an overrides table. For example:\nfunction pretty_string(tbl, overrides)\n1    return scribe(tbl, options.pretty, overrides)\nend\n\n1\n\nThe main options table is options.pretty, and we also pass along any user-provided overrides table.\n\n\nHere is an example of how the user can provide their own options table and override the indent field:\nlocal user =\n{\n    first = \"Minnie\",\n    last = \"Mouse\",\n    friends = { \"Mickey\", \"Goofy\" }\n}\nprint(classic(user, { indent = '        ' }))\nOutput:\n{\n    first = \"Minnie\",\n    last = \"Mouse\",\n    friends = { \"Mickey\", \"Goofy\" }\n}",
    "crumbs": [
      "Home",
      "Turning the Tables ..."
    ]
  },
  {
    "objectID": "pages/tutorial/index.html#metamethods",
    "href": "pages/tutorial/index.html#metamethods",
    "title": "Tutorial: Turning the Tables …",
    "section": "Metamethods",
    "text": "Metamethods\nWe mentioned that any Lua table can have an associated metatable\nThe metatable is a regular table with arbitrary data and methods like any other table. However, if a table tbl has a metatable mt, Lua will check for specially named methods, metamethods, in mt and use those in place of its built-in default operations.\nMetamethods, particularly the __index metamethod, are the keys to understanding how to use prototype and object-oriented methodologies in Lua. However, that isn’t the topic for today.\nThe one metamethod that interests us here is the __tostring function. (All Lua’s metamethods start with double underscores).\nHere’s an example where we create a metatable with a __tostring method inside it:\n1local count = 0\n2local mt = {}\n3function mt.__tostring(tbl)\n    count = count + 1\n4    return 'This is print number: ' .. tostring(count) .. ' for an array of size: ' .. #tbl\nend\n\n1\n\ncount will get incremented every time the __tostring metamethod is called.\n\n2\n\nmt is just a regular empty Lua table.\n\n3\n\nWe add a function __tostring to mt.\n\n4\n\nEvery time mt.__tostring is called, we increment count and return a string with the latest count.\n\n\nYou will frequently see the equivalent definition:\nmt.__tostring = function(tbl)\n    count = count + 1\n    return 'This is print number: ' .. tostring(count) .. ' for an array of size: ' .. #tbl\nend\nThe former style is more in keeping with most other programming languages. If you plan on expanding your horizons beyond Lua, stick with that look. However, both styles are perfectly acceptable and produce identical byte code.\nFor this metamethod to have any effect, we must attach its containing metatable to a Lua table using the setmetatable method:\nlocal arr = { 1, 2, 3 }\nsetmetatable(arr, mt)\n\n    \n     \n    \n    \nIf you just give arr a __tostring method directly, Lua will not make any redirection calls to it. For Lua to see a metamethod, you must put it in a metatable and attach the metatable to the parent object. The setmetatable call endows tbl with a hidden metatable. The existence of that metatable is what triggers Lua to redirect some of its operations to your custom definitions. Just adding metamethods directly to a table does nothing.\n\nLet’s exercise that metamethod:\nprint(tostring(arr))\nprint(tostring(arr))\nprint(tostring(arr))\nprint(tostring(arr))\nThis yields:\nThis is print number: 1 for an array of size 3\nThis is print number: 2 for an array of size 3\nThis is print number: 3 for an array of size 3\nThis is print number: 4 for an array of size 3\nThe built-in tostring method now redirects calls to the mt.__tostring method. If we remove the metatable:\nsetmetatable(tbl, nil)\nThen tostring(tbl) reverts to something like:\ntable: 0x15f852480\nWell, suppose the user is sophisticated enough to have added a custom __tostring metamethod to return a custom string for a particular table or class of tables. In that case, we should honour their effort by using that method.\nWe can add a call to the top of table_string to check for a custom __tostring metamethod and, if present, use that instead of our paltry efforts.\nHowever, it is best to make that optional, which we do by adding a field to our options table:\nlocal options = {}\noptions.pretty = {\n    indent        = '    ',\n    table_begin   = '{',\n    table_end     = '}',\n    array_begin   = '[',\n    array_end     = ']',\n    key_begin     = '',\n    key_end       = ' = ',\n    sep           = ',',\n    inline_spacer = ' ',\n    show_indices  = false,\n    comparator    = compare,\n    inline_size   = math.huge,\n    path_root     = 'table',\n    path_sep      = '.',\n    path_begin    = '&lt;',\n    path_end      = '&gt;',\n1    use_metatable = true,\n    COMPLETE      = true\n}\n\n1\n\nIf true and if there is a custom __tostring metamethod, then we redirect the table conversion to that method.\n\n\nWith that change, the top of the table_string looks like this:\nlocal function table_string(root_tbl, opts)\n    ...\n    local function process(tbl, path)\n1        if opts.use_metatable then\n2            local mt = getmetatable(tbl)\n3            if mt and mt.__tostring then return mt.__tostring(tbl) end\n        end\n        ...\n\n1\n\nCheck whether we are allowed to use metamethods.\n\n2\n\nCheck whether tbl has a metatable.\n\n3\n\nIf tbl has an associated __tostring metamethod, invoke it and return early.\n\n\nFor example, if:\nlocal count = 0\nlocal mt = {}\nfunction mt.__tostring(tbl)\n    count = count + 1\n    return 'This is print number: ' .. tostring(count) .. ' for a table of size: ' .. #tbl\nend\nlocal tbl = { 1, 2, 3 }\nsetmetatable(tbl, mt)\nThen print(pretty(tbl)) yields:\nThis is print number: 1 for a table of size: 3\n\nWhy Optional?\nCan you guess why we made using any custom __tostring metamethod controllable as a format option? When wouldn’t we want to use it?\nMetamethods like __tostring are usually attached to a whole class of tables instead of a particular instance. The method might do something specific to the class as a whole and then defer much of the work back to scribe to convert the instance data to a string.\nYou then run into the danger of chasing your tail. The custom __tostring method calls table_string, which then calls the __tostring method and so on, ad infinitum!\nIn this case, we must set the opts.use_metatable to false to break the cycle.\nHere’s an example:\nlocal count = 0\nlocal mt = {}\nfunction mt.__tostring(tbl)\n    count = count + 1\n1    local tbl_options = { use_metatable = false }\n    local tbl_string  = inline(tbl, tbl_options)\n    return 'Print: ' .. tostring(count) .. ' for table: ' .. tbl_string\nend\n\n1\n\nWith this override, the following line will cause a stack overflow.\n\n\nThen:\nlocal tbl = { 1, 2, 3 }\nsetmetatable(tbl, mt)\nprint(pretty(tbl))\nprint(pretty(tbl))\nprint(pretty(tbl))\nYields:\nPrint: 1 for table: [ 1, 2, 3 ]\nPrint: 2 for table: [ 1, 2, 3 ]\nPrint: 3 for table: [ 1, 2, 3 ]",
    "crumbs": [
      "Home",
      "Turning the Tables ..."
    ]
  },
  {
    "objectID": "pages/tutorial/index.html#the-scribe-module",
    "href": "pages/tutorial/index.html#the-scribe-module",
    "title": "Tutorial: Turning the Tables …",
    "section": "The scribe Module",
    "text": "The scribe Module\nIn Lua, if you have a file where you set:\nanswer = 42\nYou are creating a global variable answer with the value 42. This means that answer is available to all other Lua files that are loaded after this one.\nOn the other hand, if you write:\nlocal answer = 42\nYou are creating a local variable answer that is only available in the current file.\nThe same thing applies to functions. If you write:\nfunction bump(a)\n    answer = 42\n    return a + answer\nend\nThen bump is a global function that can be called from any other Lua file. Moreover, even though answer is set in the bump function, it is a global variable that can be accessed and modified from anywhere.\nOn the other hand, if you write:\nlocal function bump(a)\n    local answer = 42\n    return a + answer\nend\nThen bump is a local function that can only be called from within the current file. answer is a local variable that can only be accessed and modified within the function bump.\nPrepending local to variables and functions confines them to the enclosing scope.\nThis is a good practice because it reduces the chance of inadvertently modifying variables or functions that are used elsewhere. It also makes the intent of the code much clearer.\nIn general, you should always use local unless you have a good reason not to.\n\n    \n     \n    \n    \nIn Lua, the local keyword is used to declare variables and functions as local to the block in which they are declared. I suspect that, with the benefit of hindsight, Lua’s designers would choose to make local the default and added some other keyword to make variables global. You will have many more local variables than global ones in your code, so that switch would be very beneficial. However, that is not the way Lua is designed, so you must remember to use local to keep your code clean and maintainable.\n\nWe have been fairly careful to use local in our code to this point.\n\nModules\nThere is a further level of encapsulation that we have not yet discussed: modules.\nA module is a collection of functions and variables that are grouped together in a single Lua table. The table is returned by the module and can be used to access the functions and variables within it.\nHere is a simple example of a module in a file called answer.lua:\n1local M = {}\n\n2local answer = 42\n\n3function M.bump(a)\n    return a + answer\nend\n\n4return M\n\n1\n\nWe create a local table M to hold our module.  The name M is a common convention and has nothing to do with how the module is stored or used.\n\n2\n\nanswer is a local variable that is only accessible within the module (within answer.lua).\n\n3\n\nWe define a function bump within the module. It will become publicly accessible.\n\n4\n\nWe export the module at the end of the file where it’s defined.  The return M statement makes the module available to any other Lua file that requires it.\n\n\nTo use the module in another file, you would write:\n1local answer = require 'answer'\n2print(answer.bump(10))\n\n1\n\nrequire is a built-in Lua function that loads a module and returns the table that the module exports.\n\n2\n\nWe call the bump function from the answer module to print 52.\n\n\nNotice that the answer module is a self-contained unit. It has its own local variables (and potentially local functions) that are private and not accessible from outside the module. The only way to interact with the module is through the functions and variables that it exports. Generally, the only thing that a module exports is a table that contains the functions and variables that you want to make available to the outside world. What you call the module internally is up to you, but the convention is to use M.\nTypically, the user of the module will import the module into a local variable with the same name as the module’s file (without the .lua extension) though that is not a requirement.\nModules are a powerful way to organize your code and keep it clean and maintainable.\n\n\nThe scribe Module\nHere is a sketch of how we can turn our current code into a module defined in a file called scribe.lua:\n1local M = {}\n\n2local function indent_string(str, indent, ignore_first_line)\n    ...\nend\n\nlocal function compare(a, b)              ... end\nlocal function ordered_pairs(comparator)             ... end\nlocal function simple_string(obj)                    ... end\nlocal function empty_table_string(opts)              ... end\nlocal function metadata(root_tbl)                    ... end\nlocal function table_string(root_tbl, opts)          ... end\nlocal function table_clone(tbl)                      ... end\nlocal function complete_options_table(options, from) ... end\n\n3M.options = {}\n\n4M.options.pretty      = { ... }\n5M.options.inline      = table_clone(M.options.pretty)\n...\nM.options.classic     = table_clone(M.options.pretty)\n...\nM.options.alt         = table_clone(M.options.pretty)\n...\nM.options.json        = table_clone(M.options.pretty)\n...\nM.options.inline_json = table_clone(M.options.json)\n...\nM.options.debug       = table_clone(M.options.pretty)\n...\nM.options.default     = M.options.inline\n...\n\n6function M.scribe(obj, opts, overrides)\n    if type(obj) ~= 'table' then return simple_string(obj) end\n\n    if opts == nil then return table_string(obj, M.options.default) end\n\n    if not opts.COMPLETE then\n        local from = opts.indent == '' and M.options.inline or M.options.pretty\n        complete_options_table(opts, from)\n    end\n    if overrides == nil then return table_string(obj, opts) end\n\n    if not overrides.COMPLETE then complete_options_table(overrides, opts) end\n    return table_string(obj, overrides)\nend\n\n7function M.pretty(tbl, overrides)\n    return M.scribe(tbl, M.options.pretty, overrides)\nend\n\nfunction M.inline(tbl, overrides)       ... end\nfunction M.classic(tbl, overrides)      ... end\nfunction M.alt(tbl, overrides)          ... end\nfunction M.json(tbl, overrides)         ... end\nfunction M.inline_json(tbl, overrides)  ... end\nfunction M.debug(tbl, overrides)        ... end\n\n8return M\n\n1\n\nWe create a local table M to hold our module.  It will contain all of the functions and variables that we want to export.\n\n2\n\nWe define all the private helper functions that we need for our module.  These functions are declared as local and are not accessible from outside the module.\n\n3\n\nWe create a table M.options to hold all of the options that we will use in our module.  These will all be accessible from the outside as we want the user to be able to modify them.\n\n4\n\nWhere before we had options.pretty = { ... }, we now have M.options.pretty = { ... }.\n\n5\n\nAnd so on for the other tables of formatting parameters.\n\n6\n\nThe main scribe function is now a member of the module.  It is shown in full so you can see how it uses both public options data and private helper functions.\n\n7\n\nThis is true for all our convenience facade functions, like pretty, inline, classic, etc.\n\n8\n\nWe finish by exporting the module by returning the table M.\n\n\nHere is how you would use the scribe module in another file:\n1local scribe = require 'scribe'\n2print(scribe.pretty({a = 1, b = 2}))\n\n1\n\nWe import the scribe module into a local variable scribe.\n\n2\n\nWe call the classic function from the module to print a nicely formatted table.\n\n\nThis yields:\n{\n    a = 1,\n    b = 2\n}\n\n\nA Little Bonus\nOnce you’ve loaded the scribe module, you can access the pretty function as scribe.pretty and so on. If you care about using the pretty function a lot, you can make it available as a local variable in your file:\nlocal scribe = require 'scribe'\nlocal pretty = scribe.pretty\nlocal inline = scribe.inline\nIt would also be nice to have a shorthand for scribe.scribe.\nWe add a __call metamethod to the scribe table to do that. Lua calls this metamethod when you treat the table as a function (i.e. when you use scribe(...)).\nMetamethods do not go in the module table itself. Instead, you give the module table a metatable that contains the metamethods. This extra level can seem confusing to judge by the number of questions about it on the internet.\nIn our case, we add the __call metamethod to the metatable of the scribe module as follows:\n1local mt = {}\n2function mt.__call(_, ...) return M.scribe(...) end\n3setmetatable(M, mt)\n\nreturn M\n\n1\n\nStart with an ordinary empty table mt.\n\n2\n\nAdd the __call metamethod to the table.  The first argument to the metamethod is the table itself, but we don’t need it so we use _.  The ... collects all the arguments passed to the function.\n\n3\n\nWe endow our module table M with the metatable mt that contains the metamethods.\n\n\nYou can use _ as a placeholder for any argument you don’t need. Also, note that ... is a special variable that collects all the arguments passed to a function and forwards them unchanged.\nWith that addition, you can now use scribe as a function:\nlocal scribe = require 'scribe'\nprint(scribe({a = 1, b = 2}))\nThis will print the same table as before: {a = 1, b = 2}.\n\n\nrequire Gotcha\nrequire is a built-in Lua function that loads a module and returns whatever the module exports.\nIt looks for the module’s source file using Lua’s package.path variable. This is a long string of directories that Lua searches for files when you require them. The different directories in package.path are separated by semicolons.\nRunning Lua from the command line and typing:\nprint(package.path)\nI get something like:\n1/usr/local/share/lua/5.4/?.lua;\n/usr/local/share/lua/5.4/?/init.lua;\n/usr/local/lib/lua/5.4/?.lua;\n/usr/local/lib/lua/5.4/?/init.lua;\n2./?.lua;\n./?/init.lua\n\n1\n\nActually, the output is on a single line, but I have broken it up for clarity.\n\n2\n\nThe . refers to the current directory.\n\n\nThe first four entries are the system directories where Lua looks for modules. Those were set when Lua was installed. The ./?.lua entry tells Lua to also look for modules in the “current” directory.\nBy the way, the ? is a wildcard that Lua replaces with the file name you are searching for.\nWith this setup you drop the scribe.lua in the same directory as your main Lua file and you can require it. Everything will work fine.\nHowever, these days you are quite likely to run Lua from an IDE or perhaps via a plugin in another application. For example, I sometimes run Lua from ZeroBrane Studio which is a free lightweight IDE for Lua with a a full featured debugger (it’s cross-platform and highly recommended). Other times I run Lua from Visual Studio Code with the Lua for Visual Studio Code extension.\nIn both these cases, the current directory is not the directory where your Lua files are! Instead, it is the directory where the IDE or plugin is installed.\nWhen you run Lua from these environments, you will get an error when you try to require a module in the same directory as your main Lua file. The error will be something like:\nmodule 'scribe' not found:\n    no field package.preload['scribe']\n1    no file './scribe.lua'\n    no file '/usr/local/share/lua/5.4/scribe.lua'\n    no file '/usr/local/share/lua/5.4/scribe/init.lua'\n    ...\n\n1\n\nThis no file line will make you scratch your head!\n\n\nIt appears that Lua is looking for ./scribe.lua and not finding it even though it is clearly in the same directory as your main Lua file. You’ll probably double and triple check the file is there and that you have spelled the name correctly. Nothing will help.\nThe confusion arises because you think . is the directory where your main Lua file is but the IDE or plugin sees it as the directory where the IDE or plugin is installed.\nThe solution is to add the script’s directory to package.path. You could hardcode that directory name and append it to package.path but that’s clunky. If you change the directory structure of your project, you will have to remember to change the hardcoded path.\nInstead, you can use Lua’s debug library to get the directory of the current source file. Here is how you can do that:\n1local source_dir = debug.getinfo(1, 'S').source:match [[^@?(.*[\\/])[^\\/]-$]]\n2package.path = source_dir .. \"?.lua;\" .. package.path\n\n1\n\nThis magic incantation gets the directory of the current source file.\n\n2\n\nThis line appends the directory to package.path.\n\n\nYou can put these lines at the top of your main Lua file and they will ensure that require works correctly.\nThis isn’t terribly elegant, but it is a portable way to ensure that your modules are found in the “current” directory when you run Lua from an IDE or plugin.\n\n\nLuaRocks\nscribe, like many Lua modules, is available via LuaRocks.\nLuaRocks is the package manager for Lua modules and, when you install LuaRocks, it makes sure that any modules you install using it are available to Lua via require. It adds some LuaRocks standard directories to package.path so that Lua can find the modules.\nIf you install scribe using LuaRocks, you won’t have to worry about the require gotcha. LuaRocks will take care of everything for you.\n\n\nSummary\nAt this point we have a developed a production ready version of scribe. It produces readable outputs for complex tables with cyclical references. scribe also supports options for customizing the output in many ways.\nOur module also comes with pre-packaged styles for common output formats and simple to user-friendly functions for printing tables in those formats. For the most part, the user can just call pretty or json, etc. and get a good result without having to worry about the details.",
    "crumbs": [
      "Home",
      "Turning the Tables ..."
    ]
  },
  {
    "objectID": "pages/tutorial/index.html#formatted-output",
    "href": "pages/tutorial/index.html#formatted-output",
    "title": "Tutorial: Turning the Tables …",
    "section": "Formatted Output",
    "text": "Formatted Output\nStringing together messages using concatenation quickly becomes cumbersome.\nLua provides a simple way to format strings using the string.format method, similar to the sprintf function in C.\nprint(string.format(\"The value of %s is %.2f\", 'pi', math.pi))\nThis prints The value of pi is 3.14 to your screen.\nThe format string \"The value of %s is %.2f\" is a template containing placeholders for the values you want to insert. It is a recipe for baking a string by replacing the placeholders with the trailing arguments to string.format.\nThe general form for calling string.format is:\nstring.format(format_string, arg1, arg2, ...)\nThe first argument is the format string; the rest are the values that string.format will insert into the placeholders. It is a variadic function, which means it can take any number of arguments after the format string.\nPlaceholders like %s and %f are format specifiers that tell string.format to look for a trailing argument that is a string and another that is a floating point number. The .2 in %.2f is a format modifier, and it tells string.format to round the floating point number to two decimal places. The placeholders are replaced by the trailing arguments in the order they appear in the format string.\nstring.format is identical to the venerable sprintf function in C, and it supports almost all the same format specifiers and modifiers. We already mentioned that it adds a couple of extra format specifiers, like %q, which are not available in C. It drops a few of the more esoteric format specifiers rarely used in practice.\nAt some point, everyone recreates the same wrapper around string.format that looks like this:\n1function printf(format_string, ...)\n    print(string.format(format_string, ...))\nend\n\n1\n\nThe name used here is printf to mimic the C function of the same name.\n\n\nYou can use this function to print formatted strings like this:\nprintf(\"The value of %s is %.2f\", 'pi', math.pi)\nCreating formatted output using string.format is a big step up from concatenation, but it suffers from the problem of having no concept of a Lua table. The underlying C function is unaware of Lua’s data structures, so it sees tables as a blob of memory and prints their address.\n\nAdding Tables to the Mix\nScribe provides a scribe.format function that is a drop-in replacement for string.format with the added ability to format Lua tables.\nlocal person = {name = 'Alice', age = 42}\nprint(scribe.format(\"Data: %t\", person))\nThis prints Data: { age = 42, name = \"Alice\" } to your screen.\nWe do this by adding a new format specifier, %t, that tells scribe.format to format the trailing argument as a table. We have added several new format specifiers that allow you to format Lua tables in various ways.\nIt happens that %t, %T, %j, and %J were not already claimed as specifiers by string.format. Moreover, those specifiers are mnemonic and easy to remember:\n\n%t formats a table as an inline string.\n%T formats a table as a multiline string.\n%j formats a table as a compact inline JSON string.\n%J formats a table as a pretty-printed multiline JSON string.\n\nSo, uppercase %T and %J are for multiline output, while lowercase %t and %j are for inline output.\nThe signature for scribe.format is the same as string.format:\nfunction M.format(template, ...)\n...\nend\nThe first argument is the format string; the rest are the values we will insert into the placeholders.\nWe know that all placeholders have the form %&lt;modifier&gt;&lt;specifier&gt;, where &lt;specifier&gt; is the only required part. Our new format specifiers %t, %T, %j, and %J are no different.\nOur custom format method looks for those new specifiers in the format string. If none exist, it calls string.format with the same arguments and returns the result.\nIf it finds any new specifier, it formats the trailing table argument as a string according to the specifier. It can then replace the custom placeholder like %t in the format string with a %s. It also replaces the table argument with its formatted string description. At this point, it calls string.format with the modified format string and the rest of the arguments.\nThe tricky part is using Lua’s pattern matching to find the custom specifiers in the format string.\nfunction M.format(template, ...)\n1    if template == nil then return \"\" end\n\n2    local percent_rx = '%%+'\n    local modifier_rx = '[%-%+ #0]?%d*%.?[%d%*]*[hljztL]?[hl]?'\n3    local specifier_rx = '[diuoxXfFeEgGaAcspqtTjJ]'\n4    local placeholder_rx = string.format('%s(%s)(%s)', percent_rx, modifier_rx, specifier_rx)\n5    local table_rx = percent_rx .. '%d*[tTjJ]'\n\n6    if not template:find(table_rx) then return string.format(template, ...) end\n\n7    local table_placeholders = {}\n    local n_placeholders = 0\n8    for mod, spec in template:gmatch(placeholder_rx) do\n        n_placeholders = n_placeholders + 1\n        if spec == 't' or spec == 'T' or spec == 'j' or spec == 'J' then\n            insert(table_placeholders, { n_placeholders, mod, spec })\n        end\n    end\n\n9    local args = { ... }\n    if #args ~= n_placeholders then\n        return string.format(\"[FORMAT ERROR]: %q -- needs %d args but you sent %d!\\n\", template, n_placeholders, #args)\n    end\n\n10    for i = 1, #table_placeholders do\n        local index, mod, spec = unpack(table_placeholders[i])\n        local full_spec = mod .. spec\n\n        if full_spec == 't' then\n            args[index] = M.inline(args[index])\n        elseif full_spec == 'T' then\n            args[index] = M.pretty(args[index])\n        elseif full_spec == 'J' then\n            args[index] = M.json(args[index])\n        elseif full_spec == 'j' then\n            args[index] = M.inline_json(args[index])\n        else\n            return string.format(\"[FORMAT ERROR]: %q -- unknown table specifier: %q\\n\", template, full_spec)\n        end\n    end\n\n11    template = template:gsub(table_rx, '%%s')\n12    return string.format(template, unpack(args))\nend\n\n1\n\nAn edge case: if the format string is nil, we return an empty string.\n\n2\n\nThe pattern for matching one or more percent signs.\n\n3\n\nThe pattern for matching a format specifier.\n\n4\n\nThe pattern for matching a placeholder.\n\n5\n\nThe pattern for matching our table specifiers.\n\n6\n\nIf the format string contains no table specifiers, we can call string.format and return the result.\n\n7\n\nWe create space to store the positions of the table placeholders.\n\n8\n\nWe iterate over the placeholders in the format string and store the position of any table specifiers.\n\n9\n\nWe store the trailing arguments in a local variable.\n\n10\n\nWe iterate over the table placeholders and format the table arguments according to the specifier.\n\n11\n\nWe replace the table specifiers with %s in the format string.\n\n12\n\nWe call string.format with the modified format string and the rest of the arguments.\n\n\nA lot is going on here, but the key points are: - We use Lua’s pattern matching to find the placeholders in the format string. - We store the positions of any table specifiers. - We format the table arguments according to the specifier. - We replace the table specifiers with %s in the format string. - We call string.format with the modified format string and the rest of the arguments.\n\n\nMore Facades\nWe have added a few more facades to the scribe module to make it easier to work with formatted output. For example:\nfunction M.put(template, ...)\n1    io.stdout:write(M.format(template, ...))\nend\n\n1\n\nThe put function is a simple wrapper around scribe.format that writes the formatted string to the standard output.\n\n\nA matching putln function appends a newline character to the same output.\nfunction M.putln(template, ...)\n    io.stdout:write(M.format(template, ...), '\\n')\nend\nCorresponding eput, eputln, fput, and fputln functions write to the standard error stream and to files.",
    "crumbs": [
      "Home",
      "Turning the Tables ..."
    ]
  },
  {
    "objectID": "pages/custom-options.html",
    "href": "pages/custom-options.html",
    "title": "Custom Formatting Options",
    "section": "",
    "text": "As described in the Standard Formats page, you can directly access any of the pre-canned set of formatting options and change them at will.\nFor example, if you would prefer that putln(\"%t\", tbl) always produces very compact output you might have preliminary code like:\nlocal scribe = require 'scribe'\nscribe.options.inline.inline_spacer =  ''\nscribe.options.inline.sep           =  ','\nscribe.options.inline.key_end       =  '='\nAfter that, any call like putln(\"Table: %t\", {name = \"Mary\"}) produces the output {name=\"Mary\"} instead of the prior result { name = \"Mary\" }. This tighter style then remains in effect until you change those options back to their original settings.\nIn the Object-to-String page we pointed out that the call scribe.inline(obj) can take an optional second argument. You might use it as:\nlocal tbl = { name = \"Mary\" }\nlocal overrides = { inline_spacer = '', sep = ',', key_end = '='}\nprint(scribe.inline(tbl, overrides))\nwhich will produce the output {name=\"Mary\"}.\nHowever, in this case:\n\nThe scribe.options.inline table is unchanged.\nOn return, the overrides table will be fully fleshed out from scribe.options.inline.\n\nThis can be very handy when you are trying some experiments to hit on the precise output style you are after. Continue to tweak the overrides table until you are happy and only then use it to replace scribe.options.inline.",
    "crumbs": [
      "Home",
      "Custom Formats"
    ]
  },
  {
    "objectID": "pages/custom-options.html#introduction",
    "href": "pages/custom-options.html#introduction",
    "title": "Custom Formatting Options",
    "section": "",
    "text": "As described in the Standard Formats page, you can directly access any of the pre-canned set of formatting options and change them at will.\nFor example, if you would prefer that putln(\"%t\", tbl) always produces very compact output you might have preliminary code like:\nlocal scribe = require 'scribe'\nscribe.options.inline.inline_spacer =  ''\nscribe.options.inline.sep           =  ','\nscribe.options.inline.key_end       =  '='\nAfter that, any call like putln(\"Table: %t\", {name = \"Mary\"}) produces the output {name=\"Mary\"} instead of the prior result { name = \"Mary\" }. This tighter style then remains in effect until you change those options back to their original settings.\nIn the Object-to-String page we pointed out that the call scribe.inline(obj) can take an optional second argument. You might use it as:\nlocal tbl = { name = \"Mary\" }\nlocal overrides = { inline_spacer = '', sep = ',', key_end = '='}\nprint(scribe.inline(tbl, overrides))\nwhich will produce the output {name=\"Mary\"}.\nHowever, in this case:\n\nThe scribe.options.inline table is unchanged.\nOn return, the overrides table will be fully fleshed out from scribe.options.inline.\n\nThis can be very handy when you are trying some experiments to hit on the precise output style you are after. Continue to tweak the overrides table until you are happy and only then use it to replace scribe.options.inline.",
    "crumbs": [
      "Home",
      "Custom Formats"
    ]
  },
  {
    "objectID": "pages/custom-options.html#example",
    "href": "pages/custom-options.html#example",
    "title": "Custom Formatting Options",
    "section": "Example",
    "text": "Example\nHere is an example where we choose to show all keys including array indices. We also change the way keys are shown by putting them in square braces. Finally we change the styling for shared references:\nlocal my_options = {\n    show_indices = true,\n    key_begin    = '[',\n    key_end      = '] = ',\n    path_root    = 'ROOT',\n    path_sep     = ':'\n}\nLet’s use my_options to override the standard pretty-printing method:\nlocal list = { p1 = { name = 'Alice' }, p2 = { name = 'Maria' } }\nlist.p1.next = list.p2\nlist.p2.prev = list.p1\nlist.friends = { 'Tom', 'Dick', 'Harry' }\nlist.home    = list\nprint(scribe.pretty(list, my_options))\nThis gives the output:\n&lt;ROOT&gt; = {\n    [friends] = [ [1] = \"Tom\", [2] = \"Dick\", [3] = \"Harry\" ],\n    [home] = &lt;ROOT&gt;,\n    [p1] = { [name] = \"Alice\", [next] = &lt;p2&gt; },\n    [p2] = { [name] = \"Maria\", [prev] = &lt;p1&gt; }\n}\nAfter the call, we can look at the full version of my_options by pretty-printing it:\nprint(scribe.classic(my_options))\nto get:\n{\n    COMPLETE = true,\n    array_begin = \"[\",\n    array_end = \"]\",\n    comparator = &lt;function&gt;,\n    indent = \"    \",\n1    inline_size = inf,\n    inline_spacer = \" \",\n    key_begin = \"[\",\n    key_end = \"] = \",\n    path_begin = \"&lt;\",\n    path_end = \"&gt;\",\n    path_root = \"ROOT\",\n    path_sep = \":\",\n    sep = \",\",\n    show_indices = true,\n    table_begin = \"{\",\n    table_end = \"}\",\n    use_metatable = true\n}\n\n1\n\nHere inf refers to infinity and corresponds to the Lua value math.huge.",
    "crumbs": [
      "Home",
      "Custom Formats"
    ]
  },
  {
    "objectID": "pages/custom-options.html#cloning-options",
    "href": "pages/custom-options.html#cloning-options",
    "title": "Custom Formatting Options",
    "section": "Cloning Options",
    "text": "Cloning Options\nYou can also clone an options table to create a new one with the same settings:\nlocal my_options = scribe.clone(scribe.options.inline)\nThis is useful if you want to create a new options table with the same settings as an existing one, but with some modifications.\nOne application of this is create a __tostring metamethod for a class MyClass that defers most of the work to scribe.inline:\nlocal my_inline_options = scribe.clone(scribe.options.inline)\nmy_inline_options.use_metatable = false\n\nfunction MyClass:__tostring()\n    return scribe.inline(self, my_inline_options)\nend\nThis will create a new options table with exactly the same settings as scribe.options.inline, but with use_metatable set to false which prevents infinite recursion when printing objects of class MyClass.",
    "crumbs": [
      "Home",
      "Custom Formats"
    ]
  },
  {
    "objectID": "pages/custom-options.html#see-also",
    "href": "pages/custom-options.html#see-also",
    "title": "Custom Formatting Options",
    "section": "See Also",
    "text": "See Also\nObject-to-String Conversions  Formatting Options  Standard Options  Formatted Output  Turning the Tables …",
    "crumbs": [
      "Home",
      "Custom Formats"
    ]
  }
]